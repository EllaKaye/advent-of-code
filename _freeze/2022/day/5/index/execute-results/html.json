{
  "hash": "070effe3a5e9f90353912ac3f0349556",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2022: Day 5\"\ndate: 2022-12-5\nauthor: \n  - name: Ella Kaye\ncategories: [base R, lists, strings]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2022/day/5)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(5, 2022)\n```\n:::\n\n\nThe [input](input) is in two sections. The first represents the stack of crates, \nunderneath which is a row of digits of crate numbers. \nThen there's a blank line, followed by the instructions for moving the crates around.\nSo, our first task is to separate the input into each part.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nblank <- which(input == \"\")\nstack_numbers_index <- blank - 1\nstack_numbers <- input[stack_numbers_index]\nstacks <- input[1:(stack_numbers_index-1)]\ninstructions <- input[(blank+1):length(input)]\n```\n:::\n\n\nWhen I first saw the input, the most daunting part was thinking about how to extract the letters from the stacks. \nThe realisation that each row of `stacks` is a string of 35 characters^[`sapply(stacks, nchar) |> unname()`] made me realise that the stacks could be represented as a matrix, with each row as a vector of characters. We can then extract the letters by subsetting the matrix by column. The columns we need are the positions where the digits appear in `stack_numbers`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndigits_split <- stack_numbers |> strsplit(\"\") |> unlist() |> as.numeric() \nstack_columns <- which(!is.na(digits_split))\n\nstacks_matrix <- matrix(unlist(strsplit(stacks, split = \"\")), \n\t\t\t\t\t\t\t\t\t\t\t\tnrow = length(stacks),\n\t\t\t\t\t\t\t\t\t\t\t\tbyrow = TRUE)\nstacks_matrix_letters <- stacks_matrix[,stack_columns]\nstacks_matrix_letters\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n[1,] \" \"  \" \"  \" \"  \" \"  \"M\"  \" \"  \"V\"  \" \"  \"L\" \n[2,] \"G\"  \" \"  \" \"  \" \"  \"V\"  \"C\"  \"G\"  \" \"  \"D\" \n[3,] \"J\"  \" \"  \" \"  \" \"  \"Q\"  \"W\"  \"Z\"  \"C\"  \"J\" \n[4,] \"W\"  \" \"  \" \"  \"W\"  \"G\"  \"V\"  \"D\"  \"G\"  \"C\" \n[5,] \"R\"  \" \"  \"G\"  \"N\"  \"B\"  \"D\"  \"C\"  \"M\"  \"W\" \n[6,] \"F\"  \"M\"  \"H\"  \"C\"  \"S\"  \"T\"  \"N\"  \"N\"  \"N\" \n[7,] \"T\"  \"W\"  \"N\"  \"R\"  \"F\"  \"R\"  \"B\"  \"J\"  \"P\" \n[8,] \"Z\"  \"G\"  \"J\"  \"J\"  \"W\"  \"S\"  \"H\"  \"S\"  \"G\" \n```\n\n\n:::\n:::\n\nIn order to move the crates around, we need to be able to access the top of each stack.\nSo, next we convert the matrix into a list, where the elements are each column as a vector, removing the spaces and reversing the order of the letters in each vector.^[We don't actually need to reverse the order, but it seems more intuitive to me to have it this way round.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstacks_list <- apply(stacks_matrix_letters, 2, function(x) rev(x[x != \" \"])) \n```\n:::\n\n\nNext we need to deal with the instructions. \nHere, we write a function that takes one instruction and returns a vector of the three integers in it. We then apply this to all the instructions.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nget_values <- function(instruction) {\n\twords <- strsplit(instruction, \" \") |> unlist()\n\tints <- as.integer(words)\n\tints[!is.na(ints)] \n}\n\ninstruction_values <- lapply(instructions, get_values)\n```\n:::\n\n\nNow we can loop over the instructions, transferring the crates as required.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(instruction_values)) {\n\t\n\tinst <- instruction_values[[i]]\n\t\n\t# crates to be transferred\n\ttransfer <- stacks_list[[inst[2]]] |> # from stack inst[2]\n\t\ttail(inst[1]) |> # take inst[1] values\n\t\trev() # reverse the order\n\t\n\t# remove them from the 'from' stack\n\tstacks_list[[inst[2]]] <- stacks_list[[inst[2]]] |> \n\t\thead(-inst[1]) # remove inst[1] values\n\t\n\t# add them to the `to` stack\n\tstacks_list[[inst[3]]] <- c(stacks_list[[inst[3]]], transfer)\n}\n```\n:::\n\n\nAfter all the moving, get the crate at the top of each stack and paste them into a string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstacks_list |> sapply(tail, 1) |> paste(collapse = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"CWMTGHBDW\"\n```\n\n\n:::\n:::\n\n\n## Part 2\n\nThe only difference here is that the crates are transferred all at once. We go back to the starting configuration of crates and adapt the instructions to remove the call to `rev()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstacks_list <- apply(stacks_matrix_letters, 2, function(x) rev(x[x != \" \"])) \n\nfor (i in seq_along(instruction_values)) {\n\t\n\tinst <- instruction_values[[i]]\n\t\n\t# crates to be transferred\n\ttransfer <- stacks_list[[inst[2]]] |> # from stack inst[2]\n\t\ttail(inst[1]) # take inst[1] values\n\t\n\t# remove them from the 'from' stack\n\tstacks_list[[inst[2]]] <- stacks_list[[inst[2]]] |> \n\t\thead(-inst[1]) # remove inst[1] values\n\t\n\t# add them to the `to` stack\n\tstacks_list[[inst[3]]] <- c(stacks_list[[inst[3]]], transfer)\n}\n\nstacks_list |> sapply(tail, 1) |> paste(collapse = \"\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"SSCGWJCRB\"\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-11-18\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.504 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.0.0.9000 2023-11-17 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}