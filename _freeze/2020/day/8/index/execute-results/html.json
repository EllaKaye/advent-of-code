{
  "hash": "4212b76e1b8196b2acc42d318ce7172b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Day 8\ndate: 2020-12-8\nauthor: \n  - name: Ella Kaye\ncategories:\n  - base R\n  - loops\nopen-graph: true\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2020/day/8)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\nOur programme gets stuck in an infinite loop. As well as keeping track of the accumulator, we need to keep track of where we've visited, and stop when we visit the same instruction twice. We use a `data.frame()` rather than a `tibble()` as the former is easier to index into.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstructions <- \n  read.table(here::here(\"2020\", \"day\", \"8\", \"input\"), \n             col.names = c(\"instruction\", \"value\"))\n```\n:::\n\n\nWe start with a pretty straight-forward loop, noting that at most it can run for one more than the number of instructions in the programme until it hits an instruction it's already visited. We update row number to visit next and the accumulator as appropriate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstructions$visited <- 0\n\nrow <- 1\naccumulator <- 0\n\nnum_rows <- nrow(instructions)\n\nfor (i in 1:(num_rows+1)) {\n\n  if (instructions[row, \"visited\"] != 0) break\n  \n  # +1 on number of times the row is visited\n  instructions[row, \"visited\"] <- instructions[row, \"visited\"] + 1\n\n  # case when the instruction is \"acc\"\n  if (instructions[row, \"instruction\"] == \"acc\") {\n    accumulator <- accumulator + instructions[row, \"value\"]\n    row <- row + 1\n  }\n  \n  # case when the instruction is \"jmp\"\n  else if (instructions[row, \"instruction\"] == \"jmp\") {\n    row <- row + instructions[row, \"value\"]\n  }\n\n  # case when the instruction is \"nop\"\n  else if (instructions[row, \"instruction\"] == \"nop\") {\n    row <- row + 1\n  }\n}\n  \naccumulator\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1915\n```\n\n\n:::\n:::\n\n\n#### Part 2: Fixing the programme\n\nTo break the loop, one of the `nop` instructions in the programme should be a `jmp` or vice versa. The plan is to swap these out one by one and check if the programme completes. It's not a sophisticated approach, but it works fast enough (about a second).\n\nFirst we note that the broken instruction must be one that we visited in Part 1. Also, an instruction of `jmp` with a value of 0 will get us stuck in a one-line infinite loop, so we avoid that.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\nrows_to_check <- instructions %>%\n  mutate(row_id = row_number()) %>%\n  filter(visited != 0) %>%\n  filter(instruction != \"acc\") %>%\n  filter(!(instruction == \"nop\" & value == 0)) %>%\n  pull(row_id)\n```\n:::\n\n\nWe have 93 instruction to check. We modify our code from Part 1 slightly, converting it into a function and returning a list with values `completes` and `accumulator`. `completes` is `FALSE` as soon as we visit a row twice and `TRUE` if the number of our next row to visit is greater than the number of rows in the programme.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprogramme_completes <- function(instructions) {\n  \n  row <- 1L\n  accumulator <- 0\n  \n  num_rows <- nrow(instructions)\n  \n  for (i in 1:(num_rows+1)) {\n  \n    if (instructions[row, \"visited\"] != 0) {\n      return(list(completes = FALSE, accumulator = accumulator)) \n    }\n    \n    # +1 on number of times the row is visited\n    instructions[row, \"visited\"] <- instructions[row, \"visited\"] + 1\n  \n    # case when the instruction is \"acc\"\n    if (instructions[row, \"instruction\"] == \"acc\") {\n      accumulator <- accumulator + instructions[row, \"value\"]\n      row <- row + 1\n    }\n  \n    else if (instructions[row, \"instruction\"] == \"jmp\") {\n      row <- row + instructions[row, \"value\"]\n    }\n  \n    else if (instructions[row, \"instruction\"] == \"nop\") {\n      row <- row + 1\n    }\n  \n    if (row > num_rows) {\n      return(list(completes = TRUE, accumulator = accumulator)) \n    }\n  }\n}  \n```\n:::\n\n\nWe now loop over the rows we've identified to check, breaking the loop as soon as we find a programme that completes. Finally, we extract the accumulator value from the successful programme.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstructions$visited <- 0\n\nfor (row in rows_to_check) {\n  \n  # modify one row of the instructions,\n  # copying data frame so we don't have to modify it back\n  modified_instructions <- instructions\n  \n  ifelse(instructions[row, 1] == \"jmp\", \n         modified_instructions[row, 1] <- \"nop\", \n         modified_instructions[row, 1] <- \"jmp\") \n  \n  # check if the modified programme completes\n  check_programme <- programme_completes(modified_instructions)\n  \n  if (check_programme$completes) \n    break\n}\n\ncheck_programme$accumulator\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 944\n```\n\n\n:::\n:::\n\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.0\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-11-02\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.466 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}