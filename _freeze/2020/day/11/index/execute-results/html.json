{
  "hash": "1f4d656ad445a5687d86d698b5f8a48c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Day 11\ndate: 2020-12-11\nauthor: \n  - name: Ella Kaye\ncategories: [base R, tidyverse, matrix, loops]\nopen-graph: true\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2020/day/11)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\nMy code for Day 11 runs a little slow (about 10 seconds for Part 1 and 80 seconds for Part 2), so for the sake of being able to rebuild this page quickly as I keep updating it working through the challenges, I will demonstrate this code with the test input provided as an example.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(tidyr)\n```\n:::\n\n\nFirst we read in the data and convert it to a matrix (using the [`datapasta`](https://github.com/MilesMcBain/datapasta) package for the test input):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- tibble::tribble(\n  ~X1,\n  \"L.LL.LL.LL\",\n  \"LLLLLLL.LL\",\n  \"L.L.L..L..\",\n  \"LLLL.LL.LL\",\n  \"L.LL.LL.LL\",\n  \"L.LLLLL.LL\",\n  \"..L.L.....\",\n  \"LLLLLLLLLL\",\n  \"L.LLLLLL.L\",\n  \"L.LLLLL.LL\"\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# get number of columns for matrix\nnum_col <- layout %>%\n  mutate(length = str_length(X1)) %>%\n  slice(1) %>%\n  pull(length)\n\n# split layout into characters and turn to vector\nlayout_vec <- layout %>%\n  mutate(X1 = strsplit(X1, split = character(0), fixed = TRUE)) %>%\n  pull(X1) %>%\n  unlist()\n\n# organise into matrix\ninitial_layout <- matrix(layout_vec, ncol = num_col, byrow = TRUE)\n```\n:::\n\n\nNext, we write a helper function that, given a matrix and row and column indices, returns a vector of the adjacent seats. We need to take care when indexing into the matrix, so we treat all corner and edge cases separately. Fiddly, but gets the job done.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_adj <- function(mat, i,j) {\n  \n  nr <- nrow(mat)\n  nc <- ncol(mat)\n  \n  # corner cases\n  if (i == 1 & j == 1) {adj <- c(mat[1,2], mat[2,1:2])}\n  else if (i == 1 & j == nc) {adj <- c(mat[1,(nc-1)], mat[2,(nc-1):nc])}\n  else if (i == nr & j == 1) {adj <- c(mat[nr,2], mat[nr-1,1:2])}\n  else if (i == nr & j == nc) {adj <- c(mat[nr-1, (nc-1):nc], mat[nr, nc-1])}  \n  \n  # edge cases\n  else if (i == 1) {adj <- c(mat[1, c(j-1,j+1)], mat[2, (j-1):(j+1)])}\n  else if (i == nr) {adj <- c(mat[nr, c(j-1,j+1)], mat[nr-1, (j-1):(j+1)])}\n  else if (j == 1) {adj <- c(mat[c(i-1, i+1), 1], mat[(i-1):(i+1), 2])}\n  else if (j == nc) {adj <- c(mat[c(i-1, i+1), nc], mat[(i-1):(i+1), nc-1])}\n  \n  # inside cases\n  else {adj <- c(mat[i-1,(j-1):(j+1)], mat[i,c(j-1,j+1)], mat[i+1,(j-1):(j+1)])}\n  \n  adj\n}\n```\n:::\n\n\nOnce we have a vector of surrounding seats, we can apply the rules in the problem to determine whether a given seat needs to change state. The `needs_changing` helper function does that. It's overkill at this point to give options to specify the function for finding the vector of seats to check, and the maximum number of occupied seats people can tolerate around them, but (spolier alert) I put in these options when working on the challenge in Part 2.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nneeds_changing <- \n  function(mat, i,j, get_surround = get_adj, max_occupied = 4) {\n  \n  surround <- get_surround(mat, i,j)\n  n_occupied <- sum(surround == \"#\")\n  \n  if ((mat[i,j] == \"L\") & (n_occupied == 0)) return(TRUE)\n  \n  else if ((mat[i,j] == \"#\") & (n_occupied >= max_occupied)) {\n    return(TRUE)\n  }\n  \n  else return(FALSE)\n}\n```\n:::\n\n\nSince floor spaces don't change, we only need to consider seats. We save the indices of the seats into a data frame, so we can vectorise over it using `tidyverse` functions. However, when we've determined the seats that need changing, using our `needs_changing` function, we need to convert those indices from a data.frame into a matrix, in order to index into the layout matrix appropriately and make the changes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseats <- which(initial_layout != \".\", arr.ind = TRUE)\n\nseats_df <- as.data.frame(seats) %>%\n  rename(i = row, \n         j = col)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- initial_layout\niters <- 0\n\n# loop until there are no further changes\nrepeat {\n  \n  change <- 0\n  \n  seats_to_change <- \n    seats_df %>%\n    rowwise() %>%\n    mutate(change_seat = needs_changing(layout,i,j))   \n  \n  change <- sum(seats_to_change$change_seat)\n  \n  if (change == 0) break\n  \n  indices_to_change <- \n    seats_to_change %>%\n    filter(change_seat) %>%\n    select(i,j) %>%\n    as.matrix()  \n\n  layout[indices_to_change] <- \n    setdiff(c(\"L\", \"#\"),  layout[indices_to_change])\n  \n  iters <- iters + 1\n}\n\npart_1_iters <- iters\nsum(layout== \"#\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 37\n```\n\n\n:::\n:::\n\n\nOn the test set, this takes 5 iterations. On the full data set, my answer is 2316, and it took 107 iterations.\n\n## Part 2\n\nNow, people look to the first seat they can see in each direction, and will change from occupied to unoccupied if five or more of them are occupied.\n\nThe plan is to write a function that extracts full vectors from a given seat to the edge of the layout matrix in each of the eight directions, then finds the first seat in each of those directions, and finally collects those into a vector of the seats under consideration when determining if a change is needed. Then I can reuse the loop from Part 1, just changing the arguments in the calls to `needs_changing`.\n\nHere's a helper function to get the first seat in a vector looking in one direction:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_first_seat_from_vec <- function(vec) {\n  \n  if (any(vec %in% c(\"#\", \"L\"))) {\n    return(vec[min(which(vec != \".\"))])\n  }\n  \n  return(NA)\n}\n```\n:::\n\n\nNow, if I thought getting adjacent seats to a given seat in Part 1 was fiddly, it's nothing on getting a vector from a given seat to the edge of the matrix. There are many cases to consider to make we we don't go out of bounds. In the diagonal directions, first we get a matrix of the indices of the matrix we need, then subset into the matrix accordingly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# takes a layout matrix (elements \".\", \"#\", \"L\")\n# returns vector with first \"L\" or \"#\" encountered in each direction\nget_first_seat <- function(mat, i,j) {\n  \n  nr <- nrow(mat)\n  nc <- ncol(mat)\n  \n  # North\n  if (i == 1) N <- NA\n  if (i > 1) N <- mat[(i-1):1,j]\n  \n  # South\n  if (i == nr) S <- NA\n  if (i < nr) S <- mat[(i+1):nr,j]\n  \n  # East\n  if (j == nc) E <- NA\n  if (j < nc) E <- mat[i, (j+1):nc]\n  \n  # West\n  if (j == 1) W <- NA\n  if (j > 1) W <- mat[i, (j-1):1]\n  \n  # how far in each direction to edge of matrix\n  to_N <- i - 1\n  to_S <- nr - i\n  to_E <- nc - j\n  to_W <- j - 1\n  \n  # North-West\n  NW_length <- min(to_N, to_W)\n  \n  if (i == 1 | j == 1) NW <- NA\n  else {\n    mat_index <- \n      matrix(c((i-1):(i-NW_length), (j-1):(j-NW_length)), ncol = 2)\n    NW <- mat[mat_index]\n  }\n  \n  # North-East\n  NE_length <- min(to_N, to_E)\n  \n  if (i == 1 | j == nc) NE <- NA\n  else {\n    mat_index <- \n      matrix(c((i-1):(i-NE_length), (j+1):(j+NE_length)), ncol = 2)\n    NE <- mat[mat_index]\n  }\n  \n  # South-East\n  SE_length <- min(to_S, to_E)\n  \n  if (i == nr | j == nc) SE <- NA\n  else {\n    mat_index <- \n      matrix(c((i+1):(i+SE_length), (j+1):(j+SE_length)), ncol = 2)\n    SE <- mat[mat_index]\n  }\n  \n  # South-West\n  SW_length <- min(to_S, to_W)\n  \n  if (i == nr | j == 1) SW <- NA\n  else {\n    mat_index <- \n      matrix(c((i+1):(i+SW_length), (j-1):(j-SW_length)), ncol = 2)\n    SW <- mat[mat_index]\n  }\n\n  # vectors from mat[i,j] to the edge in each direction \n  all_vecs <- \n    (list(N = N, S = S, E = E, W = W, NW = NW, NE = NE, SE = SE, SW = SW))\n  \n  # the first seat in each direction, collapsed to a vector\n  first_seats <- purrr::map_chr(all_vecs, get_first_seat_from_vec)\n  \n  # remove NAs from list and return\n  # (these occur either when starting on an edge, \n  # or when there are no seats in a given direction)\n  return(first_seats[!is.na(first_seats)])\n\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlayout <- initial_layout\niters <- 0\n\n# loop until there are no further changes\nrepeat {\n  \n  change <- 0\n  \n  seats_to_change <- \n    seats_df %>%\n    rowwise() %>%\n    mutate(change_seat = needs_changing(layout,i,j, get_first_seat, 5))   \n  \n  change <- sum(seats_to_change$change_seat)\n  \n  if (change == 0) break\n  \n  indices_to_change <- \n    seats_to_change %>%\n    filter(change_seat) %>%\n    select(i,j) %>%\n    as.matrix()  \n\n  layout[indices_to_change] <- \n    setdiff(c(\"L\", \"#\"),  layout[indices_to_change])\n  \n  iters <- iters + 1\n}\n\npart_2_iters <- iters\nsum(layout== \"#\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 26\n```\n\n\n:::\n:::\n\n\nOn the test set, this takes 6 iterations. On the full data set, my answer is 2128, and it took 87 iterations. Given this is fewer iterations than in Part 1, it must be my code for getting the first seat that's slowing things down. \n\nI am unsatisfied both by how many lines of code this has taken as well as the time taken to run. The introduction to Advent of Code says that each challenge has a solution that will complete in at most 15 seconds on ten year old hardware. So clearly there's a better way of doing this. Perhaps something to revisit in the future.\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.0\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-11-02\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.466 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}