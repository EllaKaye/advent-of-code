{
  "hash": "d5c0659528dbe04a87ec14b9b57f4b84",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Day 7\ndate: 2020-12-7\nauthor: \n  - name: Ella Kaye\ncategories:\n  - tidyverse\n  - strings\n  - recursion\nopen-graph: true\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2020/day/7)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nWe have colour-coded bags that must contain a specific number of other colour-coded bags.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbags <- \n  read_tsv(here::here(\"2020\", \"day\", \"7\", \"input\"), col_names = FALSE)\n\nhead(bags)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  X1                                                                            \n  <chr>                                                                         \n1 wavy bronze bags contain 5 striped gold bags, 5 light tomato bags.            \n2 drab indigo bags contain 4 pale bronze bags, 2 mirrored lavender bags.        \n3 pale olive bags contain 3 faded bronze bags, 5 wavy orange bags, 3 clear blac…\n4 faded white bags contain 5 vibrant violet bags, 4 light teal bags.            \n5 mirrored magenta bags contain 2 muted cyan bags, 3 vibrant crimson bags.      \n6 dull purple bags contain 1 striped fuchsia bag.                               \n```\n\n\n:::\n:::\n\n\nOur first task is to parse the natural language and split the rules into one container/contains pair per line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrules <- bags %>%\n  mutate(rule = row_number()) %>%\n  separate(X1, c(\"container\", \"contains\"), sep = \" bags contain \") %>%\n  separate_rows(contains, sep = \",\") %>%\n  mutate(contains = str_remove(contains, \"\\\\.\")) %>%\n  mutate(contains = str_remove(contains, \"bags|bag\")) %>%\n  #mutate(contains = str_replace(contains, \"no other\", \"0 other\")) %>%\n  extract(contains, c('number', 'contains'), \"(\\\\d+) (.+)\") %>%\n  filter(!is.na(number)) %>%\n  mutate(contains = str_trim(contains)) %>%\n  mutate(number = as.integer(number)) \n\nhead(rules)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n  container   number contains           rule\n  <chr>        <int> <chr>             <int>\n1 wavy bronze      5 striped gold          1\n2 wavy bronze      5 light tomato          1\n3 drab indigo      4 pale bronze           2\n4 drab indigo      2 mirrored lavender     2\n5 pale olive       3 faded bronze          3\n6 pale olive       5 wavy orange           3\n```\n\n\n:::\n:::\n\n\nTo find all bags that con eventually contain our `shiny gold` bag, we first find the bags that can contain it directly. We then find the bags that can contain those bags and take the union of the two levels. We repeat, stopping when going up a level adds no further bags to the vector of bag colours already found. We then subtract 1, because we don't want to count the original shiny gold bag.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# function to find all colours that contain a vector of other colours:\ncontains_colours <- function(colours) {\n  rules %>%\n    filter(contains %in% colours) %>%\n    distinct(container) %>%\n    pull(container)\n}\n\nbags <- \"shiny gold\"\nold_length <- length(bags)\nnew_length <- 0\n\n# keeping adding to the vector of bags, until no change\nwhile(old_length != new_length) {\n  old_length = length(bags)\n  bags <- base::union(bags, contains_colours(bags)) %>% unique()\n  new_length <- length(bags)\n  #cat(old_length, \", \", new_length, \"\\n\")\n}\n\nlength(bags) - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 274\n```\n\n\n:::\n:::\n\n\n## Part 2\n\nNow we need to discover the number of bags that a shiny gold bag must contain. I figured that lends itself to recursion, but struggled on the details. Hat tip to David Robinson for [this solution](https://twitter.com/drob/status/1336003816395845632). I've learnt a lot for myself by unpicking how it works.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_all_contained <- function(colour) {\n  \n  relevant_rules <- rules %>%\n    filter(container %in% colour)\n  \n  sum(relevant_rules$number * \n        (1 + map_dbl(relevant_rules$contains, count_all_contained)))\n}\n\ncount_all_contained(\"shiny gold\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 158730\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.0\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-11-02\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.466 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.2   2023-04-03 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.3.0)\n purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}