{
  "hash": "a1a8f1a5c47c99d5d251daf76e348fc9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Day 2\ndate: 2020-12-2\nauthor: \n  - name: Ella Kaye\ncategories:\n  - tidyverse \n  - strings\nopen-graph: true\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2020/day/2)\n\n[My data](../../input/2020/day2.txt)\n\n## Part 1\n\n## Part 2\n\n#### Part 1: Number of letters\n\nWe need to find how many passwords are valid according to their policy. The policies and passwords are given as follows:\n\n```\n1-3 a: abcde\n1-3 b: cdefg\n2-9 c: ccccccccc\n```\n\nEach line gives the password policy and then the password. The password policy indicates the lowest and highest number of times a given letter must appear for the password to be valid. For example, `1-3 a` means that the password must contain `a` at least 1 time and at most 3 times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nFirst load the libraries we'll need. We then read in the data and use `tidyr` functions to separate out the parts of the policy and the password, making sure to convert the columns to numeric as appropriate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords <- \n  read_tsv(here::here(\"input\", \"2020\", \"day2.txt\"),\n           col_names = FALSE) %>%\n  separate(X1, c(\"policy\", \"password\"), sep = \":\") %>%\n  separate(policy, c(\"count\", \"letter\"), sep = \" \") %>%\n  separate(count, c(\"min\", \"max\")) %>%\n  mutate(min = as.integer(min),\n         max = as.integer(max))\n```\n:::\n\n\nNext, we use the `stringr` function `str_count()` to count how many times the given letter appears in the password, and conditional logic to check whether it is repeated within the specified number of times. Because `TRUE` has a numeric value of 1 and `FALSE` has a numeric value of 0, we can sum the resulting column to get a count of how many passwords are valid according to their policies.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords %>%\n  mutate(count = str_count(password, letter)) %>%\n  mutate(password_in_policy = if_else(\n    count >= min & count <= max, TRUE, FALSE)) %>%\n  summarise(correct = sum(password_in_policy)) %>%\n  pull(correct)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 625\n```\n\n\n:::\n:::\n\n\n## Part 2\n\nNow the policy is interpreted differently. Each policy actually describes two positions in the password, where 1 means the first character, 2 means the second character, and so on. Exactly one of these positions must contain the given letter. How many are valid now?\n\nThere were a couple of *gotchas* here. When I used `separate()` in the previous part, I had inadvertently left a leading whitespace in front of the password, something that was messing up my indexing with `str_sub`. Using `str_trim()` first cleared that up. Also, we need *exactly one* of the positions to match. `|` is an inclusive or. We need `xor()` for exclusive or instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npasswords %>%\n  mutate(password = str_trim(password)) %>%\n  mutate(pos1_letter = str_sub(password, min, min),\n         pos2_letter = str_sub(password, max, max)) %>%\n  mutate(match_one = xor(pos1_letter == letter, \n                         pos2_letter == letter)) %>%\n  summarise(correct = sum(match_one)) %>%\n  pull(correct) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 391\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.0\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-10-25\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.446 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.2   2023-04-03 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.3.0)\n purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}