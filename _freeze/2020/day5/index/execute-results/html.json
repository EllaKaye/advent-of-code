{
  "hash": "ff57a2c49fdc6d7dc10bdc887cc3c9a2",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Day 5\ndate: 2020-12-5\nauthor: \n  - name: Ella Kaye\ncategories:\n  - tidyverse\n  - binary\n  - base R\nopen-graph: true\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2020/day/5)\n\n[My data](../../input/2020/day5.txt)\n\n## Part 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nThe code below sets starts by setting each row number to 127 and each column number to 7, the maximum they can be, then, working along the string, lowering the maximum (or leaving it as is) one letter at a time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboarding <- \n  read_tsv(here::here(\"input\", \"2020\", \"day5.txt\"),\n           col_names = FALSE) %>%\n  rename(binary = X1)\n\nseat_IDs <- boarding %>%\n  mutate(row = 127) %>%\n  mutate(col = 7) %>%\n  mutate(row = if_else(str_sub(binary, 1, 1) == \"F\", row - 64, row)) %>%\n  mutate(row = if_else(str_sub(binary, 2, 2) == \"F\", row - 32, row)) %>%\n  mutate(row = if_else(str_sub(binary, 3, 3) == \"F\", row - 16, row)) %>%\n  mutate(row = if_else(str_sub(binary, 4, 4) == \"F\", row - 8, row)) %>%\n  mutate(row = if_else(str_sub(binary, 5, 5) == \"F\", row - 4, row)) %>%\n  mutate(row = if_else(str_sub(binary, 6, 6) == \"F\", row - 2, row)) %>%\n  mutate(row = if_else(str_sub(binary, 7, 7) == \"F\", row - 1, row)) %>%\n  mutate(col = if_else(str_sub(binary, 8, 8) == \"L\", col - 4, col)) %>%\n  mutate(col = if_else(str_sub(binary, 9, 9) == \"L\", col - 2, col)) %>%  \n  mutate(col = if_else(str_sub(binary, 10, 10) == \"L\", col - 1, col)) %>%  \n  mutate(ID = row * 8 + col) \n\nseat_IDs %>%\n  summarise(max = max(ID)) %>%\n  pull(max)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 963\n```\n\n\n:::\n:::\n\n\nOK, I know I said in the introduction to this post that I would go with the first solution I think of that gets the right answer, and the above does work, but I'm *deeply* unhappy with the code. There's too much repetition, I don't like the use of subtraction when diving by 2 feels more appropriate in a binary context, and it doesn't feel like I've taken full advantage of the mathematical structure of the problem. So, on further reflection, I realise that the way that ID is defined is essentially turning a binary number into a decimal, where we get the binary number as a string by replacing \"B\" and \"R\" by \"1\" and L\" and \"F\" by \"0\". Then, I just found, there is a base R function `strtoi()` that takes a string of digits in a given base and converts it to a base 10 integer, just what we need:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseat_IDs <- boarding %>%\n  mutate(binary = str_replace_all(binary, \"L|F\", \"0\")) %>%\n  mutate(binary = str_replace_all(binary, \"B|R\", \"1\")) %>%\n  mutate(ID = strtoi(binary, base = 2)) %>%\n  arrange(desc(ID))\n\nseat_IDs %>%\n  slice(1) %>%\n  pull(ID)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 963\n```\n\n\n:::\n:::\n\n\nThat's better!\n\n## Part 2\n\nWe need to find the missing number, so we arrange the IDs in ascending order and look at the gap between each ID and the preceding one. In most cases, that should be one. Where we have a gap of 2, we must have skipped the integer below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseat_IDs %>%\n  arrange(ID) %>%\n  mutate(diff = lag(ID)) %>%\n  mutate(gap = ID - diff) %>% \n  filter(gap == 2) %>%\n  summarise(my_seat = ID - 1) %>%\n  pull(my_seat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 592\n```\n\n\n:::\n:::\n\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.1 (2023-06-16)\n os       macOS Sonoma 14.0\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-10-25\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.446 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version date (UTC) lib source\n dplyr       * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)\n forcats     * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.2   2023-04-03 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.2   2023-02-10 [1] CRAN (R 4.3.0)\n purrr       * 1.0.1   2023-01-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2   2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)\n tibble      * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0   2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}