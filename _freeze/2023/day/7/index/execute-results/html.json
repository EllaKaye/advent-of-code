{
  "hash": "bf1dee5ba758de24fadbccadb53773e5",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 7\"\ndate: 2023-12-7\nauthor: \n  - name: Ella Kaye\ncategories: [base R, tidyverse, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/7)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\nlibrary(tidyverse)\ninput <- aoc_input_data_frame(7, 2023) |> \n  rename(hand = X1, bid = X2)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 2\n  hand    bid\n  <chr> <dbl>\n1 467K3    95\n2 JK5QK   838\n3 44664   725\n4 8QAK3   134\n5 53A3A   945\n6 7QQJ7   164\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nGet the rank of each hand, by considering both its hand type and the card values.\n:::\n\nOoh, this was fun! The puzzle lends itself well to a tidyverse approach, though with some helper functions that make use of base R stalwarts, such as `strsplit()`,  `rle()` and `match()`. Let's set up those helpers first.\n\nGiven the string of a hand, return a vector of length 5 with the individual cards. \nThey're sorted, as this will be important for the call to `rle()` later.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_cards <- function(hand) {\n\tstrsplit(hand, \"\") |> \n\t\tunlist() |> \n\t\tsort()\n}\n```\n:::\n\n\nWe can determine the hand type from the number of each card, \nand a base R function that gets that for us really neatly is `rle()`, which gives the *r*un *l*ength *e*ncoding. \nLet's see what that looks like for the hand `\"T55J5\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncards <- get_cards(\"T55J5\")\ncards\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"5\" \"5\" \"5\" \"J\" \"T\"\n```\n\n\n:::\n\n```{.r .cell-code}\nrle(cards)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRun Length Encoding\n  lengths: int [1:3] 3 1 1\n  values : chr [1:3] \"5\" \"J\" \"T\"\n```\n\n\n:::\n:::\n\nNice! We have 3 fives, 1 J and 1 T, a three of a kind. \nFor the hand type, we don't care about the values, \nso the `$lengths` element of the result is what we need.\nWe also don't care where in the run there are three, i.e.\nif `lengths` is `c(1, 3, 1)` that's still three of a kind. \nIf we sort the lengths, we can identify all three of a kinds as `c(1, 1, 3)`.\nIf we keep that as a vector though, \nit's tricky to write a `case_when()` statement that doesn't run into errors,\nso we concatenate the lengths into a single string, e.g. `\"113\"` for three of a kind.\n\nLet's take a look at the hand types, their ranks, and the associated card `rle` strings:\n\n- 1: high card: \"11111\"\n- 2: one pair: \"1112\"\n- 3: two pair: \"122\"\n- 4: three of a kind: \"113\"\n- 5: full house: \"23\"\n- 6: four of a kind, \"14\"\n- 7: five of a kind, \"5\"\n\nTaking into account all of the above, we can write a function that takes a hand and returns the rank of its hand type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_hand_type_rank <- function(hand) {\n\tcards <- get_cards(hand)\n\t\n\tcard_rle <- rle(cards)$lengths |> \n\t\tsort() |> \n\t\tpaste(collapse = \"\")\n\t\n\tcase_when(\n\t\tcard_rle == \"11111\" ~ 1,\n\t\tcard_rle == \"1112\" ~ 2,\n\t\tcard_rle == \"122\" ~ 3,\n\t\tcard_rle == \"113\" ~ 4,\n\t\tcard_rle == \"23\" ~ 5,\n\t\tcard_rle == \"14\" ~ 6,\n\t\tcard_rle == \"5\" ~ 7\n\t)\n}\n```\n:::\n\n\nWe also need to get the rank of a card. That's a job for `match()`, \nwhich returns the index of the first argument in the second argument,\ni.e. card \"2\" will return a value of 1, through to card \"A\" returning a value of 13.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_value <- function(card) {\n\tmatch(card, c(2:9, \"T\", \"J\", \"Q\", \"K\", \"A\"))\n}\n```\n:::\n\n\nNow, we can use these where needed in a pipe. \nThere are some notes about what some lines are doing in the code annotations below the chunk.^[This is my first time using code annotations, so as well as Advent of Code improving my coding skills, it's also helping me level-up my Quarto game!]\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n\trowwise() |> # <1>\n\tmutate(hand_type = get_hand_type_rank(hand)) |> \n\tseparate_wider_position(hand, # <2>\n\t                        c(card1 = 1, # <2>\n\t                          card2 = 1, # <2>\n\t                          card3 = 1, # <2>\n\t                          card4 = 1, # <2>\n\t                          card5 = 1)) |> # <2>\n\tmutate(across(starts_with(\"card\"), card_value)) |> # <3>\n\tarrange(hand_type, card1, card2, card3, card4, card5) |> # <4>\n\tmutate(rank = row_number()) |> # <5>\n\tmutate(winnings = bid * rank) |> \n\tsummarise(total_winnings = sum(winnings)) |> \n\tpull(total_winnings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 252656917\n```\n\n\n:::\n:::\n\n1. We need to use `rowwise()` as `get_hand_type_rank()` isn't vectorised.\n2. Split the `hand` column into five separate columns, one for each card. `separate_wider_position()` is one of a number of functions that supercedes `separate()`. These lines feels clunky and unintuitive to me, so I wonder if there's a better way to achieve this.\n3. `across()` allows us to run the same function on multiple columns. Here, we're getting the card value of the cards in each of the five individual card columns, which will allow us to arrange the cards.\n4. Arrange the cards, first by their hand type, then by each successive card.\n5. Now that the hands are in order, their rank is simply the row number.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nAs above, but \"J\" are now wildcards, with a lower value, but the power to be any card to make the hand as good as possible.\n:::\n\nIt's easy to rewrite the `card_value()` function to account for the new values:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_value_joker <- function(card) {\n\tmatch(card, c(\"J\", 2:9, \"T\", \"Q\", \"K\", \"A\"))\n}\n```\n:::\n\n\nNow let's think about how a joker improves each hand:\n\n- 1: high card: \"11111\"\n  - turn the \"J\" into any one of the other cards, it becomes a one pair with rank 2\n- 2: one pair: \"1112\":\n\t- if there's only 1 \"J\", make it the same as the pair for three of a kind, rank 4\n\t- if there are 2 \"J\"s, they can group with one of the ones, also three of a kind, rank 4\n- 3: two pair: 1,2,2\n\t- if there's 1 \"J\", becomes full house, rank 5\n\t- if there are 2 \"J\"s, becomes four of a kind, rank 6\n- 4: three of a kind: 1,1,3\n\t- if there's 1 \"J\", becomes four of a kind, rank 6\n\t-  if there are 3 \"J\"s, also becomes four of a kind, rank 6\n- 5: full house: 2,3\n\t-  either 2 or 3 \"J\"s, in both cases, becomes five of a kind, rank 7\n- 6: four of a kind, 1,4\n\t-  either 1 or 4 \"J\"s, in both cases, becomes five of a kind, rank 7\n- 7: five of a kind, 5: cannot be improved, rank 7\n\nWe can expand our `get_hand_type_rank()` function so that, \nafter calculating the original rank, it adjusts it as above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_hand_type_rank_joker <- function(hand) {\n\tcards <- get_cards(hand)\n\t\n\tcard_rle <- rle(cards)$lengths |> \n\t\tsort() |> \n\t\tpaste(collapse = \"\")\n\t\n\t# get hand rank regardless of joker\n\trank <- case_when(\n\t\tcard_rle == \"11111\" ~ 1,\n\t\tcard_rle == \"1112\" ~ 2,\n\t\tcard_rle == \"122\" ~ 3,\n\t\tcard_rle == \"113\" ~ 4,\n\t\tcard_rle == \"23\" ~ 5,\n\t\tcard_rle == \"14\" ~ 6,\n\t\tcard_rle == \"5\" ~ 7\n\t)\n\t\n\t# number of jokers\n\tn_j = sum(cards == \"J\")\n\t\n\t# adjust if there are jokers\n\tif (n_j > 0) {\n\t\trank <- case_when(\n\t\t\trank == 1 ~ 2,\n\t\t\trank == 2 ~ 4,\n\t\t\trank == 3 && n_j == 1 ~ 5,\n\t\t\trank == 3 && n_j == 2 ~ 6,\n\t\t\trank == 4 ~ 6,\n\t\t\trank == 5 ~ 7,\n\t\t\trank == 6 ~ 7,\n\t\t\trank == 7 ~ 7\n\t\t)\n\t}\n\t\n\trank\n}\n```\n:::\n\n\nNow we just run the same pipe again, but with the `joker` version of our functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n\trowwise() |> \n\tmutate(hand_type = get_hand_type_rank_joker(hand)) |> \n\tseparate_wider_position(hand,\n\t                        c(card1 = 1, \n\t                          card2 = 1, \n\t                          card3 = 1, \n\t                          card4 = 1, \n\t                          card5 = 1)) |> \n\tmutate(across(starts_with(\"card\"), card_value_joker)) |> \n\tarrange(hand_type, card1, card2, card3, card4, card5) |> \n\tmutate(rank = row_number()) |> \n\tmutate(winnings = bid * rank) |> \n\tsummarise(total_winnings = sum(winnings)) |> \n\tpull(total_winnings)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 253499763\n```\n\n\n:::\n:::\n\n\n## In retrospect\n\nAfter publishing my solutions, I can't help but keep thinking about them and I also then read other people's code, \nboth of which mean that I realise there are things I could have done better in my code. \nFor today's puzzle, I realised that I could have used `match()` instead of `case_when()` in `get_hand_type_rank()` to get the ranks. \nAlso, `table()` would have been simpler for getting the counts of cards in each hand than `rle()`. `cards |> table() |> sort() |> paste(collapse = \"\")` does the trick, and we also wouldn't have needed the call to `sort()` in `get_cards()`.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-08\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.515 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}