{
  "hash": "1287dda7f04b4c3490eea913c1bb84b7",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 13\"\ndate: 2023-12-13\nauthor: \n  - name: Ella Kaye\ncategories: [base R, loops, matrices, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/13)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(13, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \".##..##\" \"###..##\" \"#..##..\" \"#..##..\" \"##....#\" \".##..##\"\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFor each matrix in a list, find the line of reflection.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# helper function for wrangling the input\nlines_as_matrix <- function(lines) {\n\tstrsplit(lines, \"\") |> do.call(rbind, args = _)\n}\n\n# produce a list of matrices\nmatrix_list <- input |> \n\tsplit(cumsum(input == \"\")) |> # split at blank lines\n\tlapply(\\(x) x[x != \"\"]) |> # remove blank lines\n\tlapply(lines_as_matrix) # turn each group of lines into a matrix\n\n# find a vertical line of reflection\ncol_reflection <- function(mat) {\n\t\n\tnc <- ncol(mat)\n\t\n\t# iterate over number of columns to the left\n\t# returning that number as soon as a reflection line is found\n\tfor (i in 1:(nc-1)) {\n\t\tif (i <= nc/2) {\n\t\t\tleft_mat <- mat[, 1:i]\n\t\t\tright_mat <- mat[, (2 * i):(i + 1)]\n\t\t} else {\n\t\t\tleft_mat <- mat[,(2 * i - nc + 1):i]\n\t\t\tright_mat <- mat[, nc:(i + 1)]\n\t\t}\n\t\t\n\t\tcompare <- identical(left_mat, right_mat)\n\t\t\n\t\tif (compare) {\n\t\t\treturn(i)\n\t\t}\n\t}\n\treturn(0) # if no vertical line of reflection\n}\n\n# find a horizontal line of reflection\nrow_reflection <- function(mat) {\n\t\n\tnr <- nrow(mat)\n\t\n\t# iterate over number of rows above\n\t# returning that number as soon as a reflection line is found\n\tfor (i in 1:(nr-1)) {\n\t\tif (i <= nr/2) {\n\t\t\tabove_mat <- mat[1:i, ]\n\t\t\tbelow_mat <- mat[(2 * i):(i + 1), ]\n\t\t} else {\n\t\t\tabove_mat <- mat[(2 * i - nr + 1):i, ]\n\t\t\tbelow_mat <- mat[nr:(i + 1), ]\n\t\t}\n\t\t\n\t\tcompare <- identical(above_mat, below_mat)\n\t\t\n\t\tif (compare) {\n\t\t\treturn(100 * i) # as required in puzzle description\n\t\t}\n\t}\n\treturn(0) # if no horizontal line of reflection\n}\n\n# for a matrix, check first for horizontal mirror\n# if there isn't one, check for vertical mirror\nreflection <- function(mat) {\n\t\n\trow_mirror <- row_reflection(mat)\n\t\n\tif (row_mirror > 0) {\n\t\treturn(row_mirror)\n\t} else {\n\t\tcol_reflection(mat)\n\t}\n}\n\n# find the mirror in each matrix, \n# and the sum of the required values\nmatrix_list |> \n  sapply(reflection) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 30575\n```\n\n\n:::\n:::\n\n\nI think (hope?) it's pretty clear what the above code is doing,\nespecially when read alongside the puzzle description.\nThere's probably a way of doing this that's a lot more concise \n(though perhaps at the expense of readability), \nin particular there's a lot of repetition between `col_reflections()` and `row_reflections()`, so that could probably be refactored into one function.\n\nThe trickiest part of this for me was figuring out a correct way of indexing into a matrix to get the appropriate reflections on each side of the mirror line for `col_reflections()`.\nIt was a job for pen and paper, \nwriting out a couple of small examples in full (one with an odd number of columns, one with an even number),\nnoting the columns needed on each side of the line and staring at it until I figured out the appropriate sequences in relation to the values of `nc` and `i`.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFor each matrix in a list, fix one smudge, then find the line of reflection.\n:::\n\nThis is very similar to above, except now, when we compare the left/right or above/below matrices, we need them to be identical in all spots but one, \ni.e. different in exactly one place.\nSo, we just need to alter the calculation of `compare` in the `col_reflection()`\nand `row_reflection()` functions accordingly, \nthen run the `reflection()` function on each matrix again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncol_reflection <- function(mat) {\n\t\n\tnc <- ncol(mat)\n\t\n\tfor (i in 1:(nc-1)) {\n\t\tif (i <= nc/2) {\n\t\t\tleft_mat <- mat[, 1:i]\n\t\t\tright_mat <- mat[, (2 * i):(i + 1)]\n\t\t} else {\n\t\t\tleft_mat <- mat[,(2 * i - nc + 1):i]\n\t\t\tright_mat <- mat[, nc:(i + 1)]\n\t\t}\n\t\t\n\t\tcompare <- sum(left_mat != right_mat) == 1\n\t\t\n\t\tif (compare) {\n\t\t\treturn(i)\n\t\t}\n\t}\n\treturn(0)\n}\n\nrow_reflection <- function(mat) {\n\t\n\tnr <- nrow(mat)\n\t\n\tfor (i in 1:(nr-1)) {\n\t\tif (i <= nr/2) {\n\t\t\tabove_mat <- mat[1:i, ]\n\t\t\tbelow_mat <- mat[(2 * i):(i + 1), ]\n\t\t} else {\n\t\t\tabove_mat <- mat[(2 * i - nr + 1):i, ]\n\t\t\tbelow_mat <- mat[nr:(i + 1), ]\n\t\t}\n\t\t\n\t\tcompare <- sum(above_mat != below_mat) == 1\n\t\t\n\t\tif (compare) {\n\t\t\treturn(100 * i)\n\t\t}\n\t}\n\treturn(0)\n}\n\nmatrix_list |> \n  sapply(reflection) |> \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 37478\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-14\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.526 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}