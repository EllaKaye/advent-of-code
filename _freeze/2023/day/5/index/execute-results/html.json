{
  "hash": "621e8773b58ec991c06351f793e42667",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 5\"\ndate: 2023-12-5\nauthor: \n  - name: Ella Kaye\ncategories: [base R, tidyverse, loops, scalability issues, ⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/5)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\nlibrary(tidyverse)\n#input <- aoc_input_vector(5, 2023)\ninput <- read_lines(here::here(\"2023\", \"day\", \"5\", \"example-input\"))\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"seeds: 79 14 55 13\" \"\"                   \"seed-to-soil map:\" \n[4] \"50 98 2\"            \"52 50 48\"           \"\"                  \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nGiven a set of seeds, and a set of maps, use the maps to find the location of the closest seed.\n:::\n\nBig struggle today. \nOn December 5th itself, I finally produced a solution that worked on the example input,\neven though I knew by then that my approach wouldn't work on actual input.\nMy first attempt was a strange mash-up of base R and tidyverse, via various digressions.\nIt runs into memory issues on the full input. \nI was so determined at least to get something on the example input that I ploughed on with it regardless,\neven introducing a fudge to make it work on the specific example.\n\nI'll document the wrong approach here, as a reminder of what not to do, \nthen show a working solution that I figured out the following day, \nthanks to a tip from Tan Ho on the R4DS Slack.\n\nThe first part, wrangling the data, is the same for both approaches.\n\nWrangle the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Split the input at the blank lines, then remove the blank lines\nsplit_input <- split(input, cumsum(input == \"\")) |> \n\tlapply(\\(x) x[x != \"\"])\n\n# Get a vector of the seeds\nseeds <- split_input[[1]] |> \n\taochelpers::extract_numbers()\n\n# A list of the maps, without the map names\nmaps <- tail(split_input, -1) |> \n\tlapply(\\(x) tail(x, -1))\n```\n:::\n\n\n### A wrong approach\n\nFor each map, make a tibble for every possible source-destination pair. \nIn retrospect, this is where I started to go wrong.\nThese tibbles are billions of lines long on the full input, \nand we don't need every possible pair.\n\nTake a single item from a map, e.g. `\"50 98 2\"` and make a tibble:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_map <- function(x) {\n\tn <- x[3]\n\ttibble(\n\t\tsource = x[2]:(x[2]+n-1),\n\t\tdestination = x[1]:(x[1]+n-1)\n\t)\n}\n```\n:::\n\n\nTake a whole map, use `make_map` for each map item, and bind into a big data frame.\nThis is where the it fails on the full input. \nThe combined data frame runs out of memory.\nBy the time I put in the fudge to make this work on the example input, \nI knew that my approach wouldn't work on the full input, which is why it's only part implemented.\nI would have needed a better approach for tracking source elements that aren't covered by the map.\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_map_df <- function(map, vec = NULL) {\n\t\n\tmap <- map |> \n\t\tlapply(extract_numbers) |>\n\t\tlapply(make_map) |>\n\t\tbind_rows() \n\t\n\t# account for elements in source not in a range on the map\n\t# only implement for elements less than the minimum source\n\t# as a fudge to get this to work on the example data.\n\tif (!is.null(vec)) {\n\t\t\n\t\tmin_source <- min(map$source)\n\t\tmin_vec <- min(vec)\n\t\t\n\t\tif (min_vec < min_source) {\n\t\t\textra_vec <- min_vec:(min_source-1)\n\t\t\textra_rows <- tibble(source = extra_vec, destination = extra_vec) \n\t\t\tmap <- bind_rows(extra_rows, map)\n\t\t}\n\t} \n\t\n\tmap |> \n\t\tarrange(source)\n}\n```\n:::\n\n\nA function that joins two map tables to link the destination with the source.\nThis adds even more rows! \nIt did, at least, give me an opportunity to learn about the new `join_by()` function in dplyr v1.1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_map_table <-  function(map_table, map) {\n\tfull_join(map_table, map, join_by(destination == source)) |> \n\t\tmutate(destination.y = if_else(is.na(destination.y), destination, destination.y)) |> \n\t\tselect(-destination) |> \n\t\trename(destination = destination.y)\n}\n```\n:::\n\n\nStart with the seed-to-soil map, then iterate over the maps, \njoining them to make new source-to-destination links.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_table <- make_map_df(maps[[1]], seeds) \nfor (i in 2:length(maps)) {\n\tmap_df <- make_map_df(maps[[i]])\n\tmap_table <- build_map_table(map_table, map_df)\n}\n```\n:::\n\n\nIn the final `map_table`, the source column represents the seeds \nand the destination column represents the location. \nWe have our minumum location, at least for the example data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmap_table |> \n\tfilter(source %in% seeds) |> \n\tsummarise(min_location = min(destination)) |>\n\tpull(min_location)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 35\n```\n\n\n:::\n:::\n\n\nLessons learnt:\n\n- spend time looking at actual input and thinking of an appropriate strategy for that scale\n- don't plough on with a solution for the example input when I know it won't work on the full input\n\n### A right approach\n\nA tip from Tan Ho to work with information describing the the ranges, \nrather than expanding them in full, got me on the right track.\nI also wasn't helped above by the mash-up of tidyverse and base R approaches,\nso I went back to the familiar strategy of writing a function that takes one seed and returns its location, \nand applying it to all seeds to find the minimum.\nWe need a few helper functions first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# `source` is a single element in the source, e.g. seeds[1], \n# and `item` is a single line of a map, e.g. \"50 98 2\"\n# returns a logical indicating whether the source is in the range \n# described by the item\nsource_in_range <- function(source, item) {\n\titem <- aochelpers::extract_numbers(item)\n\t\n\tif (source >= item[2] && source <= item[2] + item[3] - 1) {\n\t\treturn(TRUE)\n\t}\n\telse {\n\t\treturn(FALSE)\n\t}\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# source is as above\n# map is a full map, i.e. a single elements of `maps`\n# returns a single element, the value of the destination\nsource_to_destination <- function(source, map) {\n\t\n\t# check if source is in each range\n\t# logical vector of length(map)\n\tis_in_range <- purrr::map_lgl(map, \\(x) source_in_range(source, x))\n\twhich_range <- which(is_in_range)\n\t\n\tif (length(which_range) == 0) {\n\t\treturn(source)\n\t}\n\telse {\n\t\t# get the item that contains the source\n\t\titem <- map[which_range] |> extract_numbers()\n\t\tdestination <- source - item[2] + item[1]\n\t\treturn(destination)\n\t}\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# starting with a seed, this function iterates over all the maps \n# to return the value of the location.\nseed_to_location <- function(seed, maps) {\n\t\n\t# start with the seed\n\tsource <- seed\n\t\n\t# iterate over maps\n\tfor (i in seq_along(maps)) {\n\t\t# get the destination\n\t\tdestination <- source_to_destination(source, maps[[i]])\n\t\t# set the source to the destination\n\t\tsource <- destination\n\t\t#cat(paste0(\"round \", i, \": source \", source, \"\\n\"))\n\t}\n\t\n\t# return the final destination\n\tdestination\n}\n```\n:::\n\n\nNow let's read in our actual input and wrangle it as before:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- aoc_input_vector(5, 2023)\nsplit_input <- split(input, cumsum(input == \"\")) |> \n\tlapply(\\(x) x[x != \"\"])\n\nseeds <- split_input[[1]] |> extract_numbers()\n\nmaps <- tail(split_input, -1) |> \n\tlapply(\\(x) tail(x, -1))\n```\n:::\n\n\nFinally, we apply `source_to_destination()` to all the seeds and find the minimum:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseeds |> \n\tsapply(\\(x) seed_to_location(x, maps)) |> \n\tmin()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 278755257\n```\n\n\n:::\n:::\n\n\nGot there!\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFind the lowest location number for any initial seed, \nbut from a *much* larger set of seeds than in Part 1.\n:::\n\nNot attempted (yet).\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-11\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.523 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}