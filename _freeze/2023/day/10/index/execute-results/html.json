{
  "hash": "3c4c1be2966d7853df5565153799c481",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 10\"\ndate: 2023-12-10\nauthor: \n  - name: Ella Kaye\ncategories: [grids, graphs, tidyverse, tidygraph, adventdrob, ⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/10)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\n# other options: aoc_input_data_frame(), aoc_input_matrix()\ninput <- aoc_input_data_frame(10, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  X1                                                                            \n  <chr>                                                                         \n1 .-FL-L777F-F.7-LJF-7.F|7F7.FF---7-F-L|-F-JJ-LL.J-F7.L-LJFF-LFFJ7.FF-F|FFFJ77-…\n2 --|J.F-7-|7F|7-|FF-J-7L|JL--.LF|.7J||F77|7.FL-7-77|--L|.F7FLJ--F--7.LL-7|LFL7…\n3 |.F-7-L..J-JJL7.||..L|--JF7...-FLJ7|L|J|777.|--J|LJF7--LLJ77.|7L77|F||7|-|L|J…\n4 7J.-J7.FFLF--.-FJ7|--J7--F|77L-|J7|..F.L7-7.J.|J|.F-F7JL-7.F7FLL|-|-JL-JFFF7J…\n5 JJ.FL7|77.L7|-.FJ-|-F.|7J|.FJLFJ7-|.7LJF|.7JJ.L.LFJFL|LLFJ7|.L7||FJ7|7|7L7J|.…\n6 L7-|JFF77J--|.L|--JFF7LJF--7|LL-|.LF|LF-7.LL77|FLJ-JFF7.-|JF7JL7-7.LJF|7J.L.F…\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFind the furthest point in a loop from the start point.\nThis is equivalent to finding the largest component in a graph,\nand half the number of its nodes.\n:::\n\nFirst, my solution in full, then explanation below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(adventdrob)\n\n# table with one row per grid element, with its row and col positions\n# and an identifier for the node it will represent in a graph.\ngrid <- input |> \n\tadventdrob::grid_tidy(X1) |> \n\tmutate(node = row_number()) \n\n# find all nodes adjacent to each other in the grid\ngrid_adj <- adventdrob::adjacent_join(grid, grid)\n\n# group values according to where the pipe is open\nopen_S <- c(\"|\", \"F\", \"7\") \nopen_N <- c(\"|\", \"L\", \"J\") \nopen_W <- c(\"-\", \"J\", \"7\") \nopen_E <- c(\"-\", \"L\", \"F\") \n\n# find the nodes that are connected\ngrid_adj_connected <- grid_adj |> \n\tmutate(is_connected = case_when(\n\t  value %in% open_S & col2 == col & row2 > row & value2 %in% open_N ~ TRUE, \n\t\tvalue %in% open_N & col2 == col & row2 < row & value2 %in% open_S  ~ TRUE, \n\t\tvalue %in% open_W & col2 < col & row2 == row & value2 %in% open_E ~ TRUE, \n\t\tvalue %in% open_E & col2 > col & row2 == row & value2 %in% open_W  ~ TRUE, \n\t\t.default = FALSE\n\t))\n\n# get nodes, edges and convert into graph\ngrid_nodes <- grid |> \n  select(node)\n\ngrid_edges <- grid_adj_connected |> \n  filter(is_connected) |> \n  select(from = node, to = node2)\n\npipe_graph <- tbl_graph(nodes = grid_nodes, edges = grid_edges) \n# not called grid_graph as that's the name of a function in adventdrob\n\n# the length of the longest path is the number of nodes in the largest component\nlongest_path <- pipe_graph |> \n\tactivate(nodes) |> \n\tmutate(group = group_components()) |> \n\tas_tibble() |> \n\tcount(group) |> \n\tslice_max(n) |> \n\tpull(n)\n\n# add 1 to the longest path to account for \"S\" (and make it a loop)\n# furthest point is half-way round.\n(longest_path + 1)/2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6831\n```\n\n\n:::\n:::\n\n\nI spent a lot of time on [Day 3](../3/index.qmd) going over David Robinson's solution to that puzzle, using his [**adventdrob**](https://github.com/dgrtwo/adventdrob).\nThat paid off today, as I was able to use the `grid_tidy()` and `adjacent_join()` functions\nto get a tidy table with a row for each pair of adjacent points. \nFor example, in `grid_adj`, we can see all the points adjacent to the start point, `\"S\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_adj |> \n  filter(value == \"S\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 8\n    row value   col  node  row2  col2 value2 node2\n  <int> <chr> <int> <int> <dbl> <dbl> <chr>  <int>\n1    17 S        38  2278    16    38 J       2138\n2    17 S        38  2278    17    37 F       2277\n3    17 S        38  2278    17    39 -       2279\n4    17 S        38  2278    18    38 F       2418\n```\n\n\n:::\n:::\n\n\nWe see that `\"S\"` is in row 17, column 38, and we can also see the values (`value2`) to its north, south, east and west. \nOn the basis of this, `\"S\"` could be any of `\"J\"`, `\"-\"` or `\"L\"`. \nIn example 1 we're shown that that `\"S\"` is `\"F\"`, \nand in example 2, `\"S\"` also has to be `\"F\"`.\nIt really bothered me as I first worked through this that there was more than one possibility in the full input, and that I had to find these by inspection.\nWhen I first ran my code, I replaced each of these in turn for `\"S\"` and got the same answer for each, which was the correct solution. \nIt wasn't clear to me why all of the three possibilities would close the loop.\nIt took me a while to see why it didn't matter what `\"S\"` is, and it only took a tiny tweak to my previous final line above to get the final line about to account for that. \n\nGoing back a bit to understand why, it was obvious to me when I first read the puzzle that we could represent the grid as a graph and that the one large, continuous loop we are looking for is equivalent to finding the largest connected component of that graph.\nGiven the set-up of the problem, if we take the largest loop and remove the start point, we'll still have the longest path, which will still be the largest connected component of the graph. \nSo, instead of changing the `\"S\"` into each of its three possible values, running the rest of the code and dividing the number of nodes in the largest component by 2 (as I originally did),\nwe can instead ignore the `\"S\"`, still find the number of nodes in the largest component, add 1 to it to account for `\"S\"`, then divide that by 2. Then we also get rid of the bother of figuring out what `\"S\"` could be.\n\nSo, that's what we're doing towards the end of the solution, \nfrom the creation of `longest_path` onwards.\nBut before we can get that, \nwe need to back up a bit and figure out how to get from `grid_adj` to a graph. \nWe're using the [**tidygraph**](https://tidygraph.data-imaginist.com) package for that, \nwhich can create a graph from a pair of data frames, \none containing information about the nodes, and one containing information about the edges.\n\nThe `graph_nodes` data frame is easy -- it's just the node identifies we gave each value at the start.\n\nTo find the edges, we need to look at each adjacent pair and figure out if they contain values that connect. \nTo do that, we first group the pipe according to where they are open to connect, for example, the pipes `\"|\"`, `\"F\"` and `\"7\"` are all open to the south, so they get grouped into `open_S`, \nand we make equivalent groups for the other three directions. \nThen, for any value that's a pipe in `open_S`, if it has directly to its south a pipe that is open to the north, those two pipes are connected. \nWe can figure similarly for the other groups of pipes.\nThis is what we're doing in `grid_adj_connected`. \nThe `graph_edges` table is then just that, filtered on the pairs of nodes that are connected.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nCount the number of points inside the loop.\n:::\n\nNot attempted (yet). \n\nWhen I first read the Part 2 description, it looked hideous and I had no idea to proceed,\nand I wasn't prepared to try and grind it out.\nI did assume that there must be some smart algorithm or formula that would be applicable, though.\nNow that it's later in the day and others have had a go and shared hints, \nI've learnt about the existence of the [Shoelace Formula](https://en.wikipedia.org/wiki/Shoelace_formula) and I may come back at some point and try to apply that here.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-10\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.523 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n adventdrob  * 0.0.1      2023-11-19 [1] Github (dgrtwo/adventdrob@491050f)\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph   * 1.2.3      2023-02-01 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}