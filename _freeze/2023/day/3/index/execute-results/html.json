{
  "hash": "3234eb6f33f44799a76d812453dae05b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 3\"\ndate: 2023-12-3\nauthor: \n  - name: Ella Kaye\ncategories: [tidyverse, grids, adventdrob, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/3)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\nThe input for this puzzle represents a grid. \nWhen I was writing the [**aochelpers**](https://ellakaye.github.io/aochelpers) package,\nI came across David Robinson's [**adventdrob**](https://github.com/dgrtwo/adventdrob) package,\nwhich contains functions that he finds useful for working with grids in Advent of Code challenges,\nin particular `grid_tidy()` and `adjacent_join()`.\nI have struggled with grid puzzles in the past, so when I saw today's, \nI immediately thought of using these functions.\nI didn't have much time today to dedicate to Advent of Code, \nso instead of attempting to solve the puzzle myself, \ninstead I decided to spend that time unpicking David's [solution](https://fosstodon.org/@drob/111514861427443202). \nHe had already posted it, and, unsurprisingly, used his package to solve it.\nI hope that this makes it easier for me to approach future Advent of Code grid puzzles.\n\nSince I'm writing up this post as a record of understanding someone else's code,\nI'm going to work through it with the example input:\n\n```\n467..114..\n...*......\n..35..633.\n......#...\n617*......\n.....+.58.\n..592.....\n......755.\n...$.*....\n.664.598..\n```\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFind the sum of all the numbers that are adjacent (including diagonally) to a symbol.\n:::\n\nFirst, I used the \"paste as tribble\" RStudio addin from the [**datapasta**](https://milesmcbain.github.io/datapasta/) package get the example input into R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- tibble::tribble(\n  ~ X1,\n   \"467..114..\",\n   \"...*......\",\n   \"..35..633.\",\n   \"......#...\",\n   \"617*......\",\n   \".....+.58.\",\n   \"..592.....\",\n   \"......755.\",\n   \"...$.*....\",\n   \".664.598..\"\n  )\n```\n:::\n\n\n::: {.callout-warning}\nThe **datapasta** addin turns the first row into a column header, \nso I needed to adjust that. \nI called it `X1` as that'll be the colname when reading in the full input with `aoc_input_data_frame()`,\n\nAlso, and this really caught me out,\nit interprets `#` as signifying a comment, so doesn't copy that, \nor anything to its right. That meant row 4 was pasted as `\"......\"` \nand I had to write in the rest of the line.\n:::\n\nI'll break down David's solution more-or-less line by line.\n`grid_tidy()` takes a data frame and, for a given column,\nproduces a data frame with one row per character, \nwith the value of that character, and a column for each of its row and column positions in the grid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(adventdrob)\ng <- input |> \n  adventdrob::grid_tidy(X1) \ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 3\n     row value   col\n   <int> <chr> <int>\n 1     1 4         1\n 2     1 6         2\n 3     1 7         3\n 4     1 .         4\n 5     1 .         5\n 6     1 1         6\n 7     1 1         7\n 8     1 4         8\n 9     1 .         9\n10     1 .        10\n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\nWe need to be able to identify the numbers.\nAt various point in what follows, that means both for individual characters,\nbut also being able to know what part number they're part of. \nThe last line of the following is a clever trick for identifying which digits group together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- g |> \n\tmutate(is_digit = str_detect(value, \"\\\\d\")) |>\n\tgroup_by(row) |> \n\tmutate(number_id = paste0(row, \".\", consecutive_id(is_digit))) \ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 5\n# Groups:   row [10]\n     row value   col is_digit number_id\n   <int> <chr> <int> <lgl>    <chr>    \n 1     1 4         1 TRUE     1.1      \n 2     1 6         2 TRUE     1.1      \n 3     1 7         3 TRUE     1.1      \n 4     1 .         4 FALSE    1.2      \n 5     1 .         5 FALSE    1.2      \n 6     1 1         6 TRUE     1.3      \n 7     1 1         7 TRUE     1.3      \n 8     1 4         8 TRUE     1.3      \n 9     1 .         9 FALSE    1.4      \n10     1 .        10 FALSE    1.4      \n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\nThe new `consecutive_id` function from **dplyr** is doing a lot of heavy lifting here.\nIt generates a unique identifier that increments every time a variable (or combination of variables) changes.^[David actually did something much fiddlier to get the same thing.\nIt was Tan Ho, in the Advent of Code channel on the R4DS Slack, \nwho later suggested this much neater option.]\n\nNow that we know which digits belong together, \nwe need to keep track of what the actual part number is:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- g |> \n  group_by(number_id) |> \n  mutate(part_number = as.numeric(paste(value, collapse = \"\"))) |> \n\tungroup() \ng\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 6\n     row value   col is_digit number_id part_number\n   <int> <chr> <int> <lgl>    <chr>           <dbl>\n 1     1 4         1 TRUE     1.1               467\n 2     1 6         2 TRUE     1.1               467\n 3     1 7         3 TRUE     1.1               467\n 4     1 .         4 FALSE    1.2                NA\n 5     1 .         5 FALSE    1.2                NA\n 6     1 1         6 TRUE     1.3               114\n 7     1 1         7 TRUE     1.3               114\n 8     1 4         8 TRUE     1.3               114\n 9     1 .         9 FALSE    1.4                NA\n10     1 .        10 FALSE    1.4                NA\n# ℹ 90 more rows\n```\n\n\n:::\n:::\n\n\nThis is the first time I'd seen this this trick to combine the values in several rows into one, and I feel like it's a good one to know now!\n\nThis data frame, `g`, is what we need for both parts, \nso let's leave it as that, and use it to start a new data frame for Part 1.\n\nWe want to find the part numbers that are adjacent to symbols.\nSo first, we narrow our attention just to the rows that represent part numbers, then look at what's around them. \n`adjacent_join()` from **adventdrob** is designed exactly for this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- g |> \n  filter(!is.na(part_number)) |> \n  adventdrob::adjacent_join(g, diagonal = TRUE) |> \n  arrange(row, col)\np1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 183 × 12\n     row value   col is_digit number_id part_number  row2  col2 value2 is_digit2\n   <int> <chr> <int> <lgl>    <chr>           <dbl> <dbl> <dbl> <chr>  <lgl>    \n 1     1 4         1 TRUE     1.1               467     1     2 6      TRUE     \n 2     1 4         1 TRUE     1.1               467     2     1 .      FALSE    \n 3     1 4         1 TRUE     1.1               467     2     2 .      FALSE    \n 4     1 6         2 TRUE     1.1               467     1     1 4      TRUE     \n 5     1 6         2 TRUE     1.1               467     1     3 7      TRUE     \n 6     1 6         2 TRUE     1.1               467     2     1 .      FALSE    \n 7     1 6         2 TRUE     1.1               467     2     2 .      FALSE    \n 8     1 6         2 TRUE     1.1               467     2     3 .      FALSE    \n 9     1 7         3 TRUE     1.1               467     1     2 6      TRUE     \n10     1 7         3 TRUE     1.1               467     1     4 .      FALSE    \n# ℹ 173 more rows\n# ℹ 2 more variables: number_id2 <chr>, part_number2 <dbl>\n```\n\n\n:::\n:::\n\n\nIt's a little tricky to see how this works from the first 10 rows, so let's look at, for example, all eight characters around the \"3\" in the third column of the third row, and their row and column positions in the grid:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 |> \n  filter(row == 3 & col == 3) |> \n  select(value2, row2, col2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  value2  row2  col2\n  <chr>  <dbl> <dbl>\n1 .          2     2\n2 .          2     3\n3 *          2     4\n4 .          3     2\n5 5          3     4\n6 .          4     2\n7 .          4     3\n8 .          4     4\n```\n\n\n:::\n:::\n\n\nWe only need to know which values are adjacent to symbols, \nso we discard the the adjectent elements (`value2`) that are either digits or \".\":\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- p1 |> \n\tfilter(value2 != \".\", !is_digit2)\np1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 12\n     row value   col is_digit number_id part_number  row2  col2 value2 is_digit2\n   <int> <chr> <int> <lgl>    <chr>           <dbl> <dbl> <dbl> <chr>  <lgl>    \n 1     1 7         3 TRUE     1.1               467     2     4 *      FALSE    \n 2     3 3         3 TRUE     3.2                35     2     4 *      FALSE    \n 3     3 5         4 TRUE     3.2                35     2     4 *      FALSE    \n 4     3 6         7 TRUE     3.4               633     4     7 #      FALSE    \n 5     3 3         8 TRUE     3.4               633     4     7 #      FALSE    \n 6     5 7         3 TRUE     5.1               617     5     4 *      FALSE    \n 7     7 2         5 TRUE     7.2               592     6     6 +      FALSE    \n 8     8 7         7 TRUE     8.2               755     9     6 *      FALSE    \n 9    10 6         3 TRUE     10.2              664     9     4 $      FALSE    \n10    10 4         4 TRUE     10.2              664     9     4 $      FALSE    \n11    10 5         6 TRUE     10.4              598     9     6 *      FALSE    \n12    10 9         7 TRUE     10.4              598     9     6 *      FALSE    \n# ℹ 2 more variables: number_id2 <chr>, part_number2 <dbl>\n```\n\n\n:::\n:::\n\n\nAlmost there. Some part numbers have more than one character adjacent to a symbol,\ne.g. both the 3 and 5 of the 35 are adjacent to the *, so we need to discard duplicate part numbers, then sum over them:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 |> \n\tdistinct(number_id, .keep_all = TRUE) |> \n\tsummarise(sum_part_numbers = sum(part_number)) |> \n\tpull(sum_part_numbers)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4361\n```\n\n\n:::\n:::\n\n\nDone! I'll come back to my input at the end of this post, \nputting everything together, \nonce we've gone through both parts.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nA **gear** is any `*` symbol that is adjacent to **exactly two part numbers**. Its **gear ratio** is the result of multiplying those two numbers together. Find the sum of all our gear ratios.\n:::\n\nLet's go back to `g` and this time start by find everything that's next to a gear.\nI'm also going to discard columns that we don't need (so all columns get printed):\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- g |> \n\tfilter(value == \"*\") |> \n\tadventdrob::adjacent_join(g, diagonal = TRUE) |> \n  select(-value, -part_number, -is_digit, -is_digit2)\np2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 24 × 8\n     row   col number_id  row2  col2 value2 number_id2 part_number2\n   <int> <int> <chr>     <dbl> <dbl> <chr>  <chr>             <dbl>\n 1     2     4 2.1           1     3 7      1.1                 467\n 2     2     4 2.1           1     4 .      1.2                  NA\n 3     2     4 2.1           1     5 .      1.2                  NA\n 4     2     4 2.1           2     3 .      2.1                  NA\n 5     2     4 2.1           2     5 .      2.1                  NA\n 6     2     4 2.1           3     3 3      3.2                  35\n 7     2     4 2.1           3     4 5      3.2                  35\n 8     2     4 2.1           3     5 .      3.3                  NA\n 9     5     4 5.2           4     3 .      4.1                  NA\n10     5     4 5.2           4     4 .      4.1                  NA\n# ℹ 14 more rows\n```\n\n\n:::\n:::\n\n\nWe only need the gears that are next to numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- p2 |> \n  arrange(row, col) |> \n\tfilter(!is.na(part_number2)) \np2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 7 × 8\n    row   col number_id  row2  col2 value2 number_id2 part_number2\n  <int> <int> <chr>     <dbl> <dbl> <chr>  <chr>             <dbl>\n1     2     4 2.1           1     3 7      1.1                 467\n2     2     4 2.1           3     3 3      3.2                  35\n3     2     4 2.1           3     4 5      3.2                  35\n4     5     4 5.2           5     3 7      5.1                 617\n5     9     6 9.1           8     7 7      8.2                 755\n6     9     6 9.1          10     6 5      10.4                598\n7     9     6 9.1          10     7 9      10.4                598\n```\n\n\n:::\n:::\n\nThere's some duplication here, \nfor example the gear in the 2nd row is next to both the \"3\" and the \"5\",\nso we filter appropriately, then summarise to create the information we'll need to filter on and use in computation later:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 <- p2 |> \n\tdistinct(number_id2, .keep_all = TRUE) |> \n  group_by(row, col) |> \n  summarise(n_adjacent_numbers = n(),\n            gear_ratio = prod(part_number2),\n            .groups = \"drop\")\np2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n    row   col n_adjacent_numbers gear_ratio\n  <int> <int>              <int>      <dbl>\n1     2     4                  2      16345\n2     5     4                  1        617\n3     9     6                  2     451490\n```\n\n\n:::\n:::\n\n\n`.groups` is an experiment feature in **dplyr** that controls the grouping structure of the output, and `\"drop\"` says all grouping levels are dropped. \nI wondered why David had used `group_by` rather than `.by` within summarise,\nbut it turns out you can't use both `.by` and `.groups` in the same call.\n\nWe finish by finding the gears (i.e. where the `*` is adjacent to just two parts), \nthen summing their ratios:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np2 |> \n\tfilter(n_adjacent_numbers == 2) |>\n\tsummarise(sum_gear_ratios = sum(gear_ratio)) |> \n\tpull(sum_gear_ratios)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 467835\n```\n\n\n:::\n:::\n\n\n## My input\nLet's put that all together, using my input.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_data_frame(3, 2023)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- input |> \n\tadventdrob::grid_tidy(X1) |> \n\tmutate(is_digit = str_detect(value, \"\\\\d\")) |>\n\tgroup_by(row) |> \n\tmutate(number_id = paste0(row, \".\", consecutive_id(is_digit))) |>\n\tgroup_by(number_id) |> \n\tmutate(part_number = as.numeric(paste(value, collapse = \"\"))) |> \n\tungroup() \n```\n:::\n\n\n### Part 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng |> \n\tfilter(!is.na(part_number)) |> \n\tadventdrob::adjacent_join(g, diagonal = TRUE) |> \n\tarrange(row, col) |> \n\tfilter(value2 != \".\", !is_digit2) |> \n\tdistinct(number_id, .keep_all = TRUE) |> \n\tsummarise(sum_part_numbers = sum(part_number)) |> \n\tpull(sum_part_numbers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 507214\n```\n\n\n:::\n:::\n\n\n### Part 2\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng |> \n\tfilter(value == \"*\") |> \n\tadventdrob::adjacent_join(g, diagonal = TRUE) |> \n\tarrange(row, col) |> \n\tfilter(!is.na(part_number2)) |>\n\tdistinct(row, col, number_id2, .keep_all = TRUE) |>\n\tgroup_by(row, col) |> \n\tsummarise(n_adjacent_numbers = n(),\n\t\t\t\t\t\tgear_ratio = prod(part_number2),\n\t\t\t\t\t\t.groups = \"drop\") |> \n\tfilter(n_adjacent_numbers == 2) |>\n\tsummarise(sum_gear_ratios = sum(gear_ratio)) |> \n\tpull(sum_gear_ratios)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 72553319\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-06\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.515 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n adventdrob  * 0.0.1      2023-11-19 [1] Github (dgrtwo/adventdrob@491050f)\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}