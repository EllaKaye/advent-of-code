{
  "hash": "a1c518b81438bffca09a3998ae8d9313",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 23\"\ndate: 2023-12-23\nauthor: \n  - name: Ella Kaye\ncategories: [grids, graphs, tidyverse, tidygraph, igraph, adventdrob, ⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/23)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_data_frame(23, 2023) \nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  X1                                                                            \n  <chr>                                                                         \n1 #.###########################################################################…\n2 #...###...#...#.......#.....#...#...#...###...#...#...###...#.....#.....#...#…\n3 ###.###.#.#.#.#.#####.#.###.#.#.#.#.#.#.###.#.#.#.#.#.###.#.#.###.#.###.#.#.#…\n4 ###...#.#.#.#.#.....#.#...#.#.#.#.#.#.#.###.#.#.#.#.#.....#.#...#.#...#.#.#.#…\n5 #####.#.#.#.#.#####.#.###.#.#.#.#.#.#.#.###.#.#.#.#.#######.###.#.###.#.#.#.#…\n6 #...#...#.#.#...###.#.#...#.#.#...#...#.>.>.#.#.#...#.....#.#...#.#...#.#.#..…\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFind the longest path on a grid between given start and end points.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(adventdrob)\nlibrary(tidygraph)\nlibrary(igraph)\n\ngrid <- input |> \n\tadventdrob::grid_tidy(X1) |> \n\tmutate(name = row_number()) \n\nstart_node <- grid |> \n\tfilter(row == 1 & value == \".\") |> \n\tpull(name)\n\nend_node <- grid |> \n\tfilter(row == nrow(input) & value == \".\") |> \n\tpull(name)\n\ngrid_adj <- adventdrob::adjacent_join(grid, grid)\n\ngrid_adj_connected <- grid_adj |> \n\tmutate(is_connected = case_when(\n\t\tvalue == \".\" & value2 == \".\" ~ TRUE,\n\t\tvalue == \">\" & row2 == row & col2 == (col + 1) & value2 == \".\" ~ TRUE,\n\t\tvalue == \"<\" & row2 == row & col2 == (col - 1) & value2 == \".\" ~ TRUE,\t\n\t\tvalue == \"^\" & row2 == (row - 1) & col2 == col & value2 == \".\" ~ TRUE,\n\t\tvalue == \"v\" & row2 == (row + 1) & col2 == col & value2 == \".\" ~ TRUE,\n\t\tvalue == \".\" & value2 == \"v\" & col2 == col & row2 == (row + 1) ~ TRUE,\n\t\tvalue == \".\" & value2 == \"^\" & col2 == col & row2 == (row - 1) ~ TRUE,\n\t\tvalue == \".\" & value2 == \"<\" & col2 == (col - 1) & row2 == row ~ TRUE,\n\t\tvalue == \".\" & value2 == \">\" & col2 == (col + 1) & row2 == row ~ TRUE,\n\t\t.default = FALSE\n\t))\n\ngrid_nodes <- grid |> \n\tselect(name)\n\ngrid_edges <- grid_adj_connected |> \n\tfilter(is_connected) |> \n\tselect(from = name, to = name2)\n\nforest_graph <- tbl_graph(nodes = grid_nodes, edges = grid_edges) \nall_paths_lengths <- all_simple_paths(forest_graph, start_node, end_node) |> \n\tlengths() \n\n# need to subtract one as paths include start node,\n# whereas we want number of steps, not number of nodes in the path\nmax(all_paths_lengths - 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2170\n```\n\n\n:::\n:::\n\n\nThe majority of the code today follows a pattern familiar from [Day 10](../10/index.qmd){target=\"_blank\"} and [Day 21](../21/index.qmd){target=\"_blank\"}. \nI'd used the [**tidygraph**](https://tidygraph.data-imaginist.com/index.html) package on both those days, but today it didn't have the functionality we need. \nWith **tidygraph**, we can find the shortest path, but here we need the longest.\nWe're told that we can never step on the same node twice, \nwhich means that the path we're looking for is the longest *simple* path.\nThe [**igraph**](https://r.igraph.org) package has a function `all_simple_paths()`,\nwhich returns a list, with one element per simple path between the given nodes.\nEach element is a vector containing all nodes in that path. \nFor this puzzle, we use `lengths()` to find the length of each of those vectors.\nWe then need to subtract one from each, as we need the number of steps, not number of nodes. \nThe max of those gets us one gold star.\n\n\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nAs Part 1, but with many more possible paths.\n:::\n\nI had thought (i.e. optimistically hoped) it would be straightforward to adapt the code to change the slopes to regular paths, then run the same code again, something like:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrid_no_slopes <- grid |> \n\tmutate(value = if_else(value %in% c(\"<\", \">\", \"^\", \"v\"), \".\", value)) \n\ngrid_no_slopes_adj <- adventdrob::adjacent_join(grid_no_slopes, grid_no_slopes)\n\ngrid_no_slopes_adj_connected <- grid_no_slopes_adj |> \n\tmutate(is_connected = if_else(value == \".\" & value2 == \".\", TRUE, FALSE))\n\ngrid_no_slopes_edges <- grid_no_slopes_adj_connected |> \n\tfilter(is_connected) |> \n\tselect(from = name, to = name2)\n\nforest_no_slopes_graph <- tbl_graph(nodes = grid_nodes, edges = grid_no_slopes_edges) \nall_paths_no_slopes_lengths <- all_simple_paths(forest_no_slopes_graph, start_node, end_node) |> \n\tlengths() \n\nmax(all_paths_no_slopes_lengths - 1)\n```\n:::\n\n\nThat ran speedily on the example input, and gave the example answer.\nHowever, on the full input, after the computer chugged away for a few minutes, \nI got the error `vector memory exhausted (limit reached?)`.\n\nThere must be a more efficient way, but that's beyond what I currently know how to do.\nIt's becoming increasingly clear to me that to be successful in the latter stages of Advent of Code, \nI'm going to need a much better understanding of data structures and algorithms.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-23\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.526 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n adventdrob  * 0.0.1      2023-11-19 [1] Github (dgrtwo/adventdrob@491050f)\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n igraph      * 1.5.1      2023-08-10 [1] CRAN (R 4.3.0)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph   * 1.3.0      2023-12-18 [1] CRAN (R 4.3.1)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}