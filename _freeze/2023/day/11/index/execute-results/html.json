{
  "hash": "be6706d5a4e4378e4379c7a859db43f4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 11\"\ndate: 2023-12-11\nauthor: \n  - name: Ella Kaye\ncategories: [base R, grids, scalability issues, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/11)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_matrix(11, 2023)\nhead(input, c(10,10))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n [1,] \".\"  \".\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [2,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \"#\"  \".\"  \".\"  \n [3,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [4,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [5,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [6,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [7,] \".\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [8,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n [9,] \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \".\"  \n[10,] \".\"  \".\"  \".\"  \".\"  \".\"  \"#\"  \".\"  \".\"  \".\"  \".\"  \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFind the shortest path (in this case, the Manhattan distance^[This is a metric in which the distance between two points is the sum of the absolute differences of their Cartesian coordinates. We can think of it like the total number of blocks you have to walk (N/S and E/W) between two intersections on the street grid of Manhattan.]) between two points, but allow for an expanding universe.\n:::\n\nHere's my first solution to Part 1. \nIt works, but it's not efficient and doesn't scale to Part 2.\nI did 'too much', i.e. literally expanded the grid, \nthen computed distances. \nThat was unnecessary (as I realised when faced with Part 2).\nBut I'm writing up this solution as a reminder to myself of what *not* to do.\nIn particular, don't be too literal about the puzzle description. \nThink before I start coding if there's a more efficient approach!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# The input is already a matrix, \n#thanks to the `aoc_input_matrix()` function from my aochelpers package.\n\n# find the indicies of the empty rows and columns\nempty_rows <- apply(input, 1, \\(x) all(x == \".\")) |> which()\nempty_cols <- apply(input, 2, \\(x) all(x == \".\")) |> which()\n\n# approach: split the matrix where there are extra rows/cols\n# then bind in another row/col to each\n# then bind them together again\n\n# functions to split the matrix\n# e.g. of the test, we want mat[1:4, ], mat[5:8], mat[9:10, ]\nsplit_rows <- function(mat, indices) {\n\tindices <- c(0, indices, nrow(mat))\n\tlapply(1:(length(indices) - 1), \n\t       \\(i) mat[(indices[i]+1):(indices[i+1]), , drop = FALSE])\n}\n\nsplit_cols <- function(mat, indices) {\n\tindices <- c(0, indices, ncol(mat))\n\tlapply(1:(length(indices) - 1), \n\t       \\(i) mat[, (indices[i]+1):(indices[i+1]), drop = FALSE])\n}\n\n# functions to add another empty row/col\nadd_empty_row <- function(mat) {\n\trbind(mat, \".\")\n}\n\nadd_empty_col <- function(mat) {\n\tcbind(mat, \".\")\n}\n\n# applying empty_rows and empty_cols to the last sub-matrix will leave \n# an extra empty row and col at the ends, but that doesn't matter.\nexpanded_input <- input |> \n\tsplit_rows(empty_rows) |> \n\tlapply(add_empty_row) |> \n\tdo.call(what = rbind, args = _) |> \n\tsplit_cols(empty_cols) |> \n\tlapply(add_empty_col) |>\n\tdo.call(what = cbind, args = _)\n\n# get the coordinates of the galaxies in the expanded input\ngalaxies <- which(expanded_input == \"#\", arr.ind = TRUE)\n\n# get a list of pairs of galaxies, by ID\neg <- expand.grid(1:nrow(galaxies), 1:nrow(galaxies))\npairs <- eg[eg$Var1 < eg$Var2, ] \ncolnames(pairs) <- c(\"galaxy1\", \"galaxy2\")\n\n# accumulator for sum of shortest paths\ntotal <- 0\n\n# loop over the pair ISs, get the galaxy coords, \n# then calculate shortest dist\n\nfor (i in 1:nrow(pairs)) {\n\tg1 <- pairs[i, \"galaxy1\"]\n\tg2 <- pairs[i, \"galaxy2\"]\n\t\n\tg1_coords <- galaxies[g1, ]\n\tg2_coords <- galaxies[g2, ]\n\t\n\tshortest_dist <- sum(abs(g1_coords - g2_coords))\n\ttotal <- total + shortest_dist\n}\ntotal\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9536038\n```\n\n\n:::\n:::\n\n\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nNow each empty row/col expands 1000000 times.\n:::\n\nAt first, I attempted to tweak my Part 1 approach, changing the `add_empty_row()` function to `add_empty_rows()` and literally adding another 999999 rows to each sub-matrix.\nIf I'd stopped to think for a moment, I should have realised that attempting to create a matrix with millions of rows and columns wasn't a good idea.^[Had I learnt nothing from [Day 5](../5/index.qmd){target=\"_blank\"}?!]\nSure enough, when I ran it, it failed due to memory issues.\n\nA *much* better approach is to calculate the distances in the original input, \nthen adjust for the number of empty rows and empty colums crossed. \nFor example, if the expansion factor is 10, \nfor each empty row crossed, we add another 9 rows. \n\nHere's the better appraoch, this time wrapped in a function,\nso we can check it on Part 1 as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalaxy_distances <- function(input, expand = 2) {\n\t\n  # find rows/cols that are all \".\"\n\tempty_rows <- apply(input, 1, \\(x) all(x == \".\")) |> which()\n\tempty_cols <- apply(input, 2, \\(x) all(x == \".\")) |> which()\n\t\n\t# co-ordinates of the galaxies\n\tgalaxies <- which(input == \"#\", arr.ind = TRUE)\n\t\n\t# all pairs of galaxies, by id \n\teg <- expand.grid(1:nrow(galaxies), 1:nrow(galaxies))\n\tpairs <- eg[eg$Var1 < eg$Var2, ] \n\tcolnames(pairs) <- c(\"galaxy1\", \"galaxy2\")\n\t\n\t# write an (anonymous) function inside the call to `apply`\n\t# This runs said function on each row (MARGIN = 1) of `pairs`, \n\t# giving the distance between each pair of galaxies\n\t# We can sum over them for the total distance\n\tapply(pairs, 1, \\(x) {\n\t\t# x is a row of `pairs`, as a vector\n\t\t\n\t  # get the distance in the original grid\n\t\tgalaxy_pair <- galaxies[x, ] # 2x2 matrix\n\t\tgalaxy_dist <- dist(galaxy_pair, \"manhattan\")\n\t\t\n\t\t# how many empty rows/cols between galaxies?\n\t\tg_rows <- galaxy_pair[,1]\n\t\tempty_rows_crossed <- sum(g_rows[1]:g_rows[2] %in% empty_rows)\n\t\tg_cols <- galaxy_pair[,2]\n\t\tempty_cols_crossed <- sum(g_cols[1]:g_cols[2] %in% empty_cols)\n\t\t\n\t\tgalaxy_dist + empty_rows_crossed*(expand-1) + empty_cols_crossed*(expand-1)\n\t}) |> \n\t\tsum()\n\t\n}\ngalaxy_distances(input, 2) # Part 1 again\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 9536038\n```\n\n\n:::\n\n```{.r .cell-code}\ngalaxy_distances(input, 1000000) # Part 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 447744640566\n```\n\n\n:::\n:::\n\n\nThe code for my original solution to Part 1 actually runs a bit faster, \n0.97 seconds compared to running `galaxy_distances(input, 2)`, \nwhich takes 1.3 seconds. \nHowever, the code in Part 1 doesn't scale,\nwhereas running `galaxy_distances(input, 1000000)` takes 1.4 seconds.\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-11\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.523 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}