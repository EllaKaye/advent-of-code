{
  "hash": "f04937d989504ccf427b35c27d5bd71f",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 8\"\ndate: 2023-12-8\nauthor: \n  - name: Ella Kaye\ncategories: [base R, regex, loops, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/8)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(8, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"LRRLRRRLRLRLLRRLRLRLLRLRLRLLLLRRRLLRRRLRRRLRRRLLRLLRLRRLRLRLRRRLLLLRRLRLRRLRRLLRRRLRRLRLRRLRRLRRLRRLRLLRRLRRLLLLRLRLRRLLRRLLRRLRLLRLRRLRRLRRLRRRLRRLLLRRLRRRLRLRRRLLRLRRLRRRLRRLLRRRLRRLRLLRRLLRRLRRLRRRLRRLLRRLRRRLRLRLRLRLRLRRLRRLLRRRLRLRRLRRRLRLRLRLRLRLRRRLRRLRRRLLRRLRLLRRRLRRLRLLLLRRRLRRLRRRR\"\n[2] \"\"                                                                                                                                                                                                                                                                                                     \n[3] \"DRM = (DLQ, BGR)\"                                                                                                                                                                                                                                                                                     \n[4] \"PKD = (TNC, DKH)\"                                                                                                                                                                                                                                                                                     \n[5] \"FSM = (LKS, KPG)\"                                                                                                                                                                                                                                                                                     \n[6] \"NDS = (KGD, HNX)\"                                                                                                                                                                                                                                                                                     \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nNavigate a network following left/right instructions and count steps until we reach the destination.\n:::\n\nDifferent approach to the write up today. \nFor each part, I'll put my full solution first then break it down afterwards.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# wrangle data from input\ninstructions <- input[1] |> strsplit(\"\") |> unlist()\nn_instructions <- length(instructions)\nnodes <- tail(input, -2)\n\n# wrangle nodes into a matrix\nmatches <- gregexpr(pattern = \"\\\\w{3}\", text = nodes)\nlist_rows <- regmatches(nodes, matches)\nnetwork <- do.call(rbind, list_rows)\ncolnames(network) <- c(\"node\", \"L\", \"R\")\nrownames(network) <- network[,1]\n\n# iterate over the network until we reach the destination\nloc <- \"AAA\"\nsteps <- 0\n\nwhile (loc != \"ZZZ\") {\n\tii <- (steps %% n_instructions) + 1 ## instruction index\n\ti <- instructions[ii] ## instruction value, \"L\" or \"R\"\n\tloc <- network[loc, i]\n\tsteps <- steps + 1\n}\nsteps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19631\n```\n\n\n:::\n:::\n\n\nWhen I saw the word 'network' in the puzzle, \nat first I thought this would be some kind of graph theory problem, but it's not. \nIt's got much more the flavour of [Day 8, 2020](../../../2020/day/8/index.qmd){target=\"_blank\"}.\n\nI decided to go from a pure base R solution today, \nincluding dealing with regex.\n\nThe wrangling of the elements of `nodes` into a suitable data structure turned out to be the most challenging part of today for me.\nWe want it in a format with three columns, one for each group of three letters, and `n_instructions` rows.\n\nMy first challenge was working in base R with regex to get the three groups of three letters out of each string.\nThe regex for three word characters is `\"\\w{3}\"`.^[`\"\\w\"` is a word character, i.e. any letter, digit or an underscore. The `\"{3}\"` indicates we want exactly three of these. When using this in R, we need to add an extra escape, `\"\\\\w{3}\"`.] To understand what `gregexpr()` does, I think it's easiest to look at an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# matches <- gregexpr(pattern = \"\\\\w{3}\", text = nodes)\n# nodes[1] is \"DRM = (DLQ, BGR)\"\nmatches[1]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1]  1  8 13\nattr(,\"match.length\")\n[1] 3 3 3\nattr(,\"index.type\")\n[1] \"chars\"\nattr(,\"useBytes\")\n[1] TRUE\n```\n\n\n:::\n:::\n\nThis output is showing us that `gregexpr(pattern = \"\\\\w{3}\", text = nodes)` has found three instances of a match to `\"\\\\w{3}\"`, \nstarting at characters 1, 8 and 13 of the input string,\nand that each of those instances is matching three characters.\nSince all elements of `nodes` have the same regex pattern, all elements of `matches` are the same. \n\nWe use `regmatches` in conjunction with the output of `gregexpr`to extract the matches from the elements of `nodes`, returning a list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# list_rows <- regmatches(nodes, matches)\nlist_rows |> head(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n[1] \"DRM\" \"DLQ\" \"BGR\"\n\n[[2]]\n[1] \"PKD\" \"TNC\" \"DKH\"\n\n[[3]]\n[1] \"FSM\" \"LKS\" \"KPG\"\n```\n\n\n:::\n:::\n\nNow we have a list where each element is a vector of length three,\nThe first, second and third elements of which should go into the first second and third columns respectively of our data structure.\n\nOne way to do this is to row-bind the elements of the list together.\nThis is a job for `do.call()`, which constructs and executes a function call from a name or a function and a list of arguments to be passed to it. So, for example, `do.call(rbind, list(1:2, 3:4, 5:6))` is equivalent to `rbind(1:2, 3:4, 5:6)`. \nFor our input, this gives the desired matrix. \nWe also set descriptive column names and set the rownames as the names of the nodes, which makes it easy to extract values with `[]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# network <- do.call(rbind, list_rows)\n# colnames(network) <- c(\"node\", \"L\", \"R\")\n# rownames(network) <- network[,1]\nhead(network)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    node  L     R    \nDRM \"DRM\" \"DLQ\" \"BGR\"\nPKD \"PKD\" \"TNC\" \"DKH\"\nFSM \"FSM\" \"LKS\" \"KPG\"\nNDS \"NDS\" \"KGD\" \"HNX\"\nKQQ \"KQQ\" \"DPF\" \"GKD\"\nSBX \"SBX\" \"DDL\" \"MGH\"\n```\n\n\n:::\n:::\n\n\nAfter initiating the loop, the last detail of interest is the use of modular arithmetic with `%%` to repeat the series of instructions as necessary.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nAs above, but with several possible starts and finishes. Find when all paths land on a destination node simultaneously.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_nodes <- network[,1]\nstart_nodes <- all_nodes[grep(\"..A\", all_nodes)] # <1>\nend_nodes <- all_nodes[grep(\"..Z\", all_nodes)] # <1>\n\nsteps_from_start <- function(start_loc) { # <2>\n\t\n\tloc <- start_loc\n\tsteps <- 0\n\t\n\t# needs just to end in Z\n\twhile (!(loc %in% end_nodes)) {\n\t\tii <- (steps %% n_instructions) + 1 ## instruction index\n\t\ti <- instructions[ii] ## instruction value, \"L\" or \"R\"\n\t\tloc <- network[loc, i]\n\t\tsteps <- steps + 1\n\t}\n\tsteps\n}\n\nall_paths <- sapply(start_nodes, steps_from_start)\n\n# function for greatest common denominator\n# applies Euclid's algorithm\ngcd <- function(x, y) {\n\twhile (y != 0) {\n\t\tt <- y\n\t\ty <- x %% y\n\t\tx <- t\n\t}\n\tx\n}\n\n# function for lowest common multiple\nlcm <- function(x, y) {\n\tx * y / gcd(x, y)\n}\n\n# paths all reach a destination simultaneously at the lcm of their steps\noptions(digits = 14) # <3>\nReduce(lcm, all_paths) # <4>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 21003205388413\n```\n\n\n:::\n:::\n\n1. `grep(pattern, x)` returns the indices of matches to `pattern` in `x`\n2. It's not best practice to have a function look up objects in the environment, \ne.g. to rely on previously defined `locations` and `network` rather than pass them as arguments to the function, but I'm never going to use this function again, so I can get away with it.\n3. The answe is large, so need to increase the number of digits printed to display it all in a format that can be pasted into the Advent of Code answer submission box.\n4, `lcm()` only takes two arguments. Using `Reduce()` successively applies it to each element is `all_paths`.\n\nIt's not obviously from the text for Part 2 that the lowest common multiple of the part lengths is what we need. \nIt's not necessarily the case from the description that this would in fact be the solution.\nThe example suggests it though: one path takes 2 steps to reach a node, the other takes 3 steps, so they both reach an end node together after 6 steps. \nBoth example paths also loop: the first through `11B` and `11Z`, the second through `22B`, `22C` and `22Z`. \n\nSince I had committed myself to solving this puzzle purely in base R,\nI wrote my own functions for `lcm` and `gcd`.^[There are already versions of these in the **pracma** package]. I found the formula for the most efficent caluclation of the lowest common multiple on [Stack Overflow](https://stackoverflow.com/questions/3154454/what-is-the-most-efficient-way-to-calculate-the-least-common-multiple-of-two-int), which in turn took me to [Wikipedia](https://en.wikipedia.org/wiki/Euclidean_algorithm) for details on how to implement the Euclidean algorithm to find the greatest common divisor.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-09\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.523 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}