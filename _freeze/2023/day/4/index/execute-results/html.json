{
  "hash": "78fddde215b9f644b14c1f14b2451a6c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 4\"\ndate: 2023-12-4\nauthor: \n  - name: Ella Kaye\ncategories: [base R, strings, loops, ⭐⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/4)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\n# other options: aoc_input_data_frame(), aoc_input_matrix()\ninput <- aoc_input_vector(4, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Card   1: 95 57 30 62 11  5  9  3 72 87 | 94 72 74 98 23 57 62 14 30  3 73 49 80 96 20 60 17 35 11 63 87  9  6  5 95\"\n[2] \"Card   2: 65 16 99  4 48 52 84  7 26 12 | 86  7 71 12 52  4 84 15 48 20 16  3 10 87 56 99 26 66 88 65 98 32 14 51 59\"\n[3] \"Card   3: 19 70  1 34 10 79 23 58 64 68 | 95 14 64 53 19 63 83 46 77 75  3 12 70 65 22 13 66 34 23 89 94 50 69 79 68\"\n[4] \"Card   4: 27 57 62  6 53 68 97 35 23  8 | 23  2 81 62 19  8 65 27 93 53 57 67  6 91 68 97 16 30 12 96 15 35 25 55 43\"\n[5] \"Card   5: 49 95 30 21 42 63 92 97 89 93 | 35 34 46 89 93 29 42 21 63 49 77 30 95 27 28 62 72 32 97 54 75 56  4 58 92\"\n[6] \"Card   6:  7 39 29 54 34 40 63 64 32 23 | 88  4 54 73 32 18 36 31 19 35 61 94 28 40 23 41 96 59 14 48 77 29 39 21 33\"\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nFor each card, the numbers to the `left` of the `|` are the winning numbers, \nand the numbers to the `right` of the `|` are the numbers we have. \nWe need to find the number of matches between the two sets. \nThe first match makes the card worth one point \nand each match after the first doubles the point value of that card. \nHow many points do we have in total?\n:::\n\nAfter yesterday's foray into grids, we're back into much more familiar territory today. \nThe handling of the strings is similar to [Day 2](../2/index.qmd), \nas is the strategy of writing a function to find the worth of one card, \nthen applying that to all cards and finding the sum. \nI'm once again using a combination of base R plus **stringr**.\n\nFirst, here's a function that finds how many matches there are for a card.\nThis function will prove useful in Part 2 as well.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nn_card_matches <- function(card) {\n  # split the string into a vector of length 3:\n  # the card ID, the winning numbers, and the numbers we have\n\tcard_split <- str_split(card, \":|\\\\|\") |> unlist()\n\t\n\t# for the strings representing sets of values,\n\t# split into a vector of individual numeric values\n\twinning_numbers <- card_split[2] |> \n\t\tstr_extract_all(\"\\\\d+\") |> \n\t\tunlist() |> \n\t\tas.numeric()\n\t\n\tmy_numbers <- card_split[3] |> \n\t\tstr_extract_all(\"\\\\d+\") |> \n\t\tunlist() |> \n\t\tas.numeric()\n\t\n\t# the number of matches \n\tsum(my_numbers %in% winning_numbers)\n}\n```\n:::\n\n\nWe can use this in a function to find the worth of a card:^[We need to handle the case of no matches separately, \notherwise we'd get a value of 0.5 when `n_winners` is 0.] \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncard_worth <- function(card) {\n\t\n\tn_winners <- card |> \n\t\tn_card_matches() \n\t\n\tifelse(n_winners == 0, 0, 2^(n_winners-1))\n}\n```\n:::\n\n\nNow apply this to all cards, and find the total:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(input, card_worth) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19135\n```\n\n\n:::\n:::\n\n\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nThis is hard to summarise, and took me a while to get my head around,\nso here's the full puzzle description and example input:\n\nNow scratchcards only cause you to win more scratchcards equal to the number of winning numbers you have.\n\nSpecifically, you win copies of the scratchcards below the winning card equal to the number of matches. So, if card 10 were to have 5 matching numbers, you would win one copy each of cards 11, 12, 13, 14, and 15.\n\nCopies of scratchcards are scored like normal scratchcards and have the same card number as the card they copied. So, if you win a copy of card 10 and it has 5 matching numbers, it would then win a copy of the same cards that the original card 10 won: cards 11, 12, 13, 14, and 15. This process repeats until none of the copies cause you to win any more cards. (Cards will never make you copy a card past the end of the table.)\n\nThis time, the above example goes differently:\n\n```\nCard 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\nCard 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\nCard 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\nCard 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\nCard 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\nCard 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\n```\n\n- Card 1 has four matching numbers, so you win one copy each of the next four cards: cards 2, 3, 4, and 5.\n- Your original card 2 has two matching numbers, so you win one copy each of cards 3 and 4.\n- Your copy of card 2 also wins one copy each of cards 3 and 4.\n- Your four instances of card 3 (one original and three copies) have two matching numbers, so you win four copies each of cards 4 and 5.\n- Your eight instances of card 4 (one original and seven copies) have one matching number, so you win eight copies of card 5.\n- Your fourteen instances of card 5 (one original and thirteen copies) have no matching numbers and win no more cards.\n- Your one instance of card 6 (one original) has no matching numbers and wins no more cards.\n\nOnce all of the originals and copies have been processed, \nyou end up with 1 instance of card 1, \n2 instances of card 2, \n4 instances of card 3, \n8 instances of card 4, \n14 instances of card 5, \nand 1 instance of card 6. \nIn total, this example pile of scratchcards causes you to ultimately have 30 scratchcards!\n\nProcess all of the original and copied scratchcards until no more scratchcards are won. Including the original set of scratchcards, how many total scratchcards do you end up with?\n:::\n\nMy solution below may appear simple, but it took me a while to get my head round,\nso I want here to explain really clearly what each part of the code is doing,\nprimarily for my own future reference. \nI'll do this by demonstating it on the example input:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- c(\"Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53\", \n           \"Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19\", \n           \"Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1\", \n           \"Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83\", \n           \"Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36\", \n           \"Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11\")\n```\n:::\n\n\n\nThe overall strategy is first to create a vector, `n_of_card`, \nto store the number we have of each card. \nWe then iterate over the cards, \nfirst processing Card 1, \nthen all copies of Card 2,\nthen all copies of Card 3 etc until we've been through all the card numbers.\nIn each round of the loop, we update `n_of_card` to account for the copies won, \nso that any point, the value of `n_of_card[i]` is the number of copies of card `i` that we have.\n\nWe start with one of each card, so let's initialise `n_of_card` to that:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_of_card <- rep(1, length(input))\n```\n:::\n\n\nThen the loop. \nI've added a print statement to hopefully make it clear what's happening in each iteration.\nWe don't see anything printed for Card 5 and 6 as no additional cards are won so there's nothing to do.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in seq_along(n_of_card)) {\n\t\n\t# get number cards won\n\tn_won <- n_card_matches(input[i])\n\n\t# process cards won, if any\n\tif (n_won > 0) {\n\t\t# get indices of cards won:\n\t\t# this is a sequence of length n_won, starting at i+1\n\t\tcards_won <- (i+1):(i+n_won)\n\t\t\n\t\t# update the appropiate elements of n_of_card\n\t\tn_of_card[cards_won] <- n_of_card[cards_won] + n_of_card[i]\n\t\t\n\t\tcat(paste(\"After all copies of card\", i, \n\t\t          \"have been processed we have\\n\", \n\t\t          paste(n_of_card, collapse = \", \"), \n\t\t          \"copies of cards 1 to 6 respectively\\n\"))\n\t} \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAfter all copies of card 1 have been processed we have\n 1, 2, 2, 2, 2, 1 copies of cards 1 to 6 respectively\nAfter all copies of card 2 have been processed we have\n 1, 2, 4, 4, 2, 1 copies of cards 1 to 6 respectively\nAfter all copies of card 3 have been processed we have\n 1, 2, 4, 8, 6, 1 copies of cards 1 to 6 respectively\nAfter all copies of card 4 have been processed we have\n 1, 2, 4, 8, 14, 1 copies of cards 1 to 6 respectively\n```\n\n\n:::\n:::\n\nTo break this down further, in iteration 1, `n_won` is 4, \nso we update the values `n_of_cards[2:5]` with one copy of each.\nIt's one of each because we only have one copy of card 1, \ni.e. `n_of_card[1]` is 1 at the start of this iteration.\n\nIn iteration 2, `n_won` is 2, so we update the values of `n_of_cards[3:4]`.\nBut by now we have two copies of card 2, i.e. that's the value now of `n_of_card[2]`,\nso we have to add two to our tally of cards 3 and 4.\n\nAnd so on.\n\nNow, let's go back to our full input, run the loop on that, then get our total:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- aoc_input_vector(4, 2023)\n\nn_of_card <- rep(1, length(input))\n\nfor (i in seq_along(n_of_card)) {\n\tn_won <- n_card_matches(input[i])\n\tif (n_won > 0) {\n\t\tcards_won <- (i+1):(i+n_won)\n\t\tn_of_card[cards_won] <- n_of_card[cards_won] + n_of_card[i]\n\t} \n}\n\nsum(n_of_card)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 5704953\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-06\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.515 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}