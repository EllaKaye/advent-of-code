{
  "hash": "cf06fe1b207ba3fe2980525fe34e8d47",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 1\"\ndate: 2023-12-1\nauthor: \n  - name: Ella Kaye\ncategories: [base R, C, strings, regex]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/1)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n\nI solved this puzzle in both R and, stretching myself, C.\n\n### R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(1, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rhqrpdxsqhgxzknr2foursnrcfthree\"                \n[2] \"2bmckl\"                                         \n[3] \"four95qvkvveight5\"                              \n[4] \"2tqbxgrrpmxqfglsqjkqthree6nhjvbxpflhr1eightwohr\"\n[5] \"7two68\"                                         \n[6] \"nine7twoslseven4sfoursix\"                       \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\n\nCombine the first and last digits that appear in each element of `input` to a single two-digit number, then sum them for all elements.\n\n:::\n\nI found this straightforward, similar to [Day 4, 2022](../../../../2022/day/4/index.qmd). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value <- function(x) {\n\tx <- strsplit(x, \"\") |> unlist()\n\tx_nums <- x[x %in% 1:9]\n\tpaste0(head(x_nums, 1), tail(x_nums, 1)) |> \n\t\tas.numeric()\n}\n\nsapply(input, get_value) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55208\n```\n\n\n:::\n:::\n\n\n### C\n\nBefore Advent of Code started this year, \nI thought if there was one challenge I'd be able to solve in C,\nit would probably be Part 1 of Day 1. \nWhen the puzzle was released, it did indeed seem doable, \nthough there was still plenty I had to figure out for the first time.\nThis was also an opportunity to get an assist from LLMs, \nfor the parts I was unfamiliar with.\n\nThe overall strategy was the same with the R solution, \nto write a `get_value()` function, then, in `main()`, loop over the input\ncalling it on each line. \n\nFirst, here's my `get_value()` function. \nIn C, strings are arrays, and this loops over the array in both directions,\ngoing left-to-right to find the first occurence of a digit,\nthen right-to-left to find the last, with each loop breaking once a digit has been found, and updating the value of `value` appropriately.\n\n\n::: {.cell}\n\n```{.c .cell-code}\nint get_value(char input[]) {\n\t\n\t// get the length of the string\n\tint length = strlen(input);\n\t\n\t// to store the value\n\tint value = 0;\n\t\n\t// find the first digit\t\n\tfor (int i = 0; i < length; i++) {\n\t\tif (input[i] > '0' && input[i] <= '9') {\n\n\t\t\t// convert to int and update value\n\t\t\tvalue = (input[i] - '0')*10;\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\t\n\t// find the last digit\n\tfor (int i = length; i >= 0; i--) {\n\t\tif (input[i] > '0' && input[i] <= '9') {\n\n\t\t\tvalue += (input[i] - '0');\n\t\t\tbreak;\n\t\t\t\n\t\t}\n\t}\n\t\n\treturn value;\n}\n```\n:::\n\n\nAs for the role of LLMs in this, \nI came up with the overall strategy and Copilot suggested the code \n`if (input[i] > '0' && input[i] <= '9')` and also `value = (input[i] - '0')` (I needed to amend it with the mulitiplication by 10).\nI hadn't come across character literals before, so I asked ChatGPT to explain the code `value = input[i] - '0'`, which was really helpful.[^1]\n\n[^1]: The key parts of the ChatPGT explanation for me were:\n\n\tIn C, the code value = (input[i] - '0') is typically used to convert a character representing a digit into its corresponding numeric value. \n\t\n\t- `'0'`: This represents the character literal for the digit 0. In the ASCII character set, the digits 0 to 9 are represented consecutively. Therefore, subtracting the ASCII value of '0' from the ASCII value of a digit character gives the numeric value of that digit.\n\t- `(input[i] - '0')`: By subtracting the ASCII value of '0' from the ASCII value of the character at `input[i]`, you get the numeric value of the digit represented by that character. This is a common technique used for converting digit characters to their corresponding integer values.\n\t\nFor `main()`, new to me was reading in input from a file.\nI tried various comments to encourage Copilot to show me the way,\nbut it didn't oblige. \nI found the way on [w3schools](https://www.w3schools.com/c/c_files_read.php).\nOne part not covered there is how to ensure that the array in which the line of\ninput is stored is an appropriate length, \nso I used R to find the length of the longest string in my input^[`input |> sapply(nchar) |> max()`], \nand set the array size to one larger that that.\n\nHere's my `main()`:\n\n\n::: {.cell}\n\n```{.c .cell-code}\nint main(void) {\n\t\n\tFILE *fptr;\n\t\n\t// Open a file in read mode\n\tfptr = fopen(\"input\", \"r\");\n\t\n\t// Store the content of the (line of) the file\n\tchar input_line[50];\n\t\n\t// Set up accumulator\n\tint total = 0;\n\t\n\t// Read the content and store it inside input_line\n\twhile (fgets(input_line, 50, fptr)) {\n\t\tint value = get_value(input_line);\n\t\ttotal += value;\n\t}\n\t\n\t// Close the file\n\tfclose(fptr);\n\t\n\tprintf(\"%d\\n\", total);\n}\n```\n:::\n\n\nPutting this all together, including the appropriate header files and function declarations, we get a final [script](script.c){target=\"_blank\"}.\n\nI compiled it with `clang -o script script.c` and ran it with `./script` \nand was delighted to see the same total print in the console that I'd found with R.[^2]\n\n[^2]: Actually, at first I got the wrong answer because, \nin the second loop of `get_value()`, I'd used `i > 0` instead of `i >= 0` (damn the difference in indexing between R and C!)\nThis mistake is only a problem when the line of input contains just one digit which appears at the beginning of the string (which hadn't been an issue testing this on the example input). \nI don't know any debugging techniques in C, but I threw in some `printf` statements and, fortuitously, the second line of my input is this problem case, so I spotted it.\nI'm not sure I'd have been so lucky in catching my error if the trouble wasn't caused for several hundred lines of my one thousand line input.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\n\nAs Part 1, except this time the 'digit' can also be a word, e.g. \"six\".\n\n:::\n\nBack to R, and Part 2, on the other hand, was not straightforward at all,\nespecially for a Day 1 puzzle! \nAt first I was pretty stumped, though after some experimentation and an insight,\nI was able to solve it without recourse to LLMs.\n\nLike Part 1, I wrote a function that works on one line of input, then applied it to all of them.\nUnlike Part 1, it doesn't suit splitting up the string into characters -- \ninstead we need to bring on the regex!\n\nMy first thought was `str_extract_all` from the **stringr** package, \nbut that couldn't handle the overlapping words, \ne.g. in `\"eightwothree\"` it found `\"eight\"` and `\"three\"`, but not `\"two\"`.\n`str_extract()` is good for finding the first match for a digit/word though.\n\nThe breakthrough insight that got me to my solution is that finding the last digit/word is equivalent to finding the first digit/word of the string in reverse. \nSo first, I wrote a quick function to reverse a string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_reverse <- function(x) {\n\tstrsplit(x, \"\") |> \n\t\tunlist() |> \n\t\trev() |> \n\t\tpaste0(collapse = \"\")\n}\n```\n:::\n\n\nNext, we need to build the regex for matching a digit/word, \nboth forwards and in reverse.\nWe create `nums` first, then collapse it and add the regex for a digit, \nbecause we need `nums` later to `match()` a word to its corresponding value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\nnums_pattern <- paste(nums, collapse = \"|\")\nnums_digit_pattern <- paste0(nums_pattern, \"|\\\\d\")\n\nnums_pattern_rev <- string_reverse(nums_pattern)\nnums_digit_pattern_rev <- paste0(nums_pattern_rev, \"|\\\\d\")\n```\n:::\n\n\nTo get the last digit, we can then use `str_extract()` on a reversed input string, \nthough we need to reverse the output back again to turn it into a number-word:[^3]\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nget_last_digit <- function(x) {\n\tstr_extract(string_reverse(x), nums_digit_pattern_rev) |> \n\t\tstring_reverse() \n}\n```\n:::\n\n\n[^3]: In retrospect, I could have had a fully base R solution if instead of `str_extract` I'd used\n\n\t```\n\tmatches <- regexpr(nums_digit_pattern_rev, string_reverse(x)) \n  regmatches(string_reverse(x), m = matches)\n\t```\n\t\n\tbut thank goodness for **stringr** with its much more intuitive function names and approach!\n\nWe also need to convert the string to a numeric, \nfor either a spelled out word or a character digit:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_to_digit <- function(x) {\n\tif (nchar(x) == 1) {\n\t\tx <- as.numeric(x)\n\t} else {\n\t\tx <- match(x, nums)\n\t}\n\tx\n}\n```\n:::\n\n\nPutting this all together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value2 <- function(x) {\n\n\tfirst <- str_extract(x, nums_digit_pattern)\n\t\n\tlast <- get_last_digit(x)\n\t\n\tfirst_digit <- convert_to_digit(first)\n\tlast_digit <- convert_to_digit(last)\n\t\n\t10*first_digit + last_digit\n}\n\nsapply(input, get_value2) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54578\n```\n\n\n:::\n:::\n\n\nThat was quite a lot for Day 1! \nPerhaps I'll come back another time and attempt a solution to Part 2 in C,\nbut given how tricky that was in R, I expect it would be quite a challenge for me.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-01\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.504 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.0.0.9000 2023-11-28 [1] Github (EllaKaye/aochelpers@58fe238)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}