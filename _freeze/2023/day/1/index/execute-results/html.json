{
  "hash": "03ceee7767edb0b0ef3b7d465918c815",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 1\"\ndate: 2023-12-1\nauthor: \n  - name: Ella Kaye\ncategories: [base R, tidyverse, strings, regex]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/1)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(1, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"rhqrpdxsqhgxzknr2foursnrcfthree\"                \n[2] \"2bmckl\"                                         \n[3] \"four95qvkvveight5\"                              \n[4] \"2tqbxgrrpmxqfglsqjkqthree6nhjvbxpflhr1eightwohr\"\n[5] \"7two68\"                                         \n[6] \"nine7twoslseven4sfoursix\"                       \n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\n\nCombine the first and last digits that appears in each element of `input` to a single two-digit number, then sum them for all elements.\n\n:::\n\nI found this straightforward, similar to [Day 4, 2022](../../../../2022/day/4/index.qmd). \n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value <- function(x) {\n\tx <- strsplit(x, \"\") |> unlist()\n\tx_nums <- x[x %in% 1:9]\n\tpaste0(head(x_nums, 1), tail(x_nums, 1)) |> as.numeric()\n}\n\nsapply(input, get_value) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55208\n```\n\n\n:::\n:::\n\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\n\nAs Part 1, except this time the 'digit' can also be a word, e.g. \"six\".\n\n:::\n\nPart 2, on the other hand, was not straightforward at all, \nespecially for a Day 1 puzzle! \nAt first I was pretty stumped, though after some experimentation and an insight,\nI was able to solve it without recourse to LLMs.\n\nLike Part 1, I wrote a function that works on one line of input, then applied it to all of them.\nUnlike Part 1, it doesn't suit splitting up the string into characters -- \ninstead we need to bring on the regex!\n\nMy first thought was `str_extract_all` from the **stringr** package, \nbut that couldn't handle the overlapping words, \ne.g. in `\"eightwothree\"` it found `\"eight\"` and `\"three\"`, but not `\"two\"`.\n`str_extract()` is good for finding the first match for a digit/word though.\n\nThe breakthrough insight that got me to my solution is that finding the last digit/word is equivalent to finding the first digit/word of the string in reverse. \nSo first, I wrote a quick function to reverse a string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstring_reverse <- function(x) {\n\tstrsplit(x, \"\") |> unlist() |> rev() |> paste0(collapse = \"\")\n}\n```\n:::\n\n\nNext, we need to build the regex for matching a digit/word, \nboth forwards and in reverse.\nWe create `nums` first, then collapse it and add the regex for a digit, \nbecause we need `nums` later to `match()` a word to its corresponding value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnums <- c(\"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\")\nnums_pattern <- paste(nums, collapse = \"|\")\nnums_digit_pattern <- paste0(nums_pattern, \"|\\\\d\")\n\nnums_pattern_rev <- string_reverse(nums_pattern)\nnums_digit_pattern_rev <- paste0(nums_pattern_rev, \"|\\\\d\")\n```\n:::\n\n\nTo get the last digit, we can then use `str_extract()` on a reversed input string, \nthough we need to reverse the output back again to turn it into a number-word:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nget_last_digit <- function(x) {\n\tstr_extract(string_reverse(x), nums_digit_pattern_rev) |> string_reverse() \n}\n```\n:::\n\n\nWe also need to convert the string to a numeric, \nfor either a spelled out word or a digit as a character vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconvert_to_digit <- function(x) {\n\tif (nchar(x) == 1) {\n\t\tx <- as.numeric(x)\n\t} else {\n\t\tx <- match(x, nums)\n\t}\n\tx\n}\n```\n:::\n\n\nPutting this all together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_value2 <- function(x) {\n\n\tfirst <- str_extract(x, nums_digit_pattern)\n\t\n\tlast <- get_last_digit(x)\n\t\n\tfirst_digit <- convert_to_digit(first)\n\tlast_digit <- convert_to_digit(last)\n\t\n\t10*first_digit + last_digit\n}\n\nsapply(input, get_value2) |> sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54578\n```\n\n\n:::\n:::\n\n\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-01\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.504 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.0.0.9000 2023-11-28 [1] Github (EllaKaye/aochelpers@58fe238)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}