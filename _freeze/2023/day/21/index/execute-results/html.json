{
  "hash": "6829cb0818bba984e508680b2e650b39",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2023: Day 21\"\ndate: 2023-12-21\nauthor: \n  - name: Ella Kaye\ncategories: [grids, graphs, tidyverse, tidygraph, adventdrob, ⭐]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/21)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_data_frame(21, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 1\n  X1                                                                            \n  <chr>                                                                         \n1 .............................................................................…\n2 ................................#.#..........#...............................…\n3 ....#...................#..........##....#.............#.................##..…\n4 .....#...#....#.............#..#.......#....#.#.............................#…\n5 ..............#.#...........###...#........#..........##.....................…\n6 ...........#..............#............#........................#...........#…\n```\n\n\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nIn a grid, represented as a graph, \nfind how many nodes can be reached in exactly 64 steps from a given start point.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(tidygraph)\nlibrary(adventdrob)\n\ngrid <- input |> \n\tadventdrob::grid_tidy(X1) |> \n\tmutate(node = row_number()) \n\ngrid_adj <- adventdrob::adjacent_join(grid, grid)\n\ngrid_adj_connected <- grid_adj |> \n\tmutate(is_connected = if_else(\n\t  value %in% c(\".\", \"S\") & value2 == \".\", TRUE, FALSE))\n\n# get nodes, edges and convert into graph\ngrid_nodes <- grid |> \n\tselect(node)\n\ngrid_edges <- grid_adj_connected |> \n\tfilter(is_connected) |> \n\tselect(from = node, to = node2)\n\ngarden_graph <- tbl_graph(nodes = grid_nodes, \n                          edges = grid_edges, \n                          directed = FALSE) \n\n# root node\nroot_node <- grid |> \n\tfilter(value == \"S\") |> \n\tpull(node)\n\ngarden_depth <- garden_graph |> \n\tactivate(nodes) |> \n\tmutate(depth = bfs_dist(root = root_node)) |> \n\tas_tibble() \n\neven_depth <- seq(2, 64, by = 2)\n\n# everywhere in even number of steps, \n# plus one more for the starting point\ngarden_depth |> \n\tfilter(depth %in% even_depth) |> \n\tnrow() |> \n\tsum(1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3841\n```\n\n\n:::\n:::\n\n\nToday provided an opportunity to build on what I'd learnt on [Day 3](../3/index.qmd) and [Day 10](../10/index.qmd). \nThe start of my solution today is almost identical to Day 10, using the the `grid_tidy()` and `adjacent_join()` functions in [**adventdrob**](https://github.com/dgrtwo/adventdrob) to find created a tibble of adjacent points on the grid, then, treating the grid points as nodes on a graph, some logic to determine where the edges are. \nFrom there, the [**tidygraph**](https://tidygraph.data-imaginist.com) package converts the edge and node data into a graph.\n\nPrior to this year's Advent of Code, I read a some blog posts about what it takes to be successful on the global leaderboard. \nEven though I had no intention of competing on that, \nsome of the advice was relevant to more generally solving the problems. \nOne tip was to be familiar with algorithms that come up each year, e.g. [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra's_algorithm), [breadth-first search (BFS)](https://en.wikipedia.org/wiki/Breadth-first_search) and [depth-first search (DFS)](https://en.wikipedia.org/wiki/Depth-first_search), none of which I'd come across before. \nI'd never previously made it far enough into Advent of Code to face a puzzle that required any of those.\nIt seemed that today's puzzle was a good candidate for BFS, though, and thankfully **tidygraph** has functions to implement it (coding up my own version remains a challenge for another year!) For each node that is reachable from the root node, `bfs_dist()` returns the number of steps it takes. That's exactly what we need for today. \nThe only twist is that, in this puzzle, we can turn back on ourselves, \nso the points that we can reach after exactly 64 steps are the points we can reach in any number of even steps between 2 and 64, plus the root node itself.\n\nOne note about `bfs_dist()`: I would have liked to give the node names something more descriptive, that captured the information about their position on the grid, e.g. `\"1.1\"` for the upper left node. That would have made it slightly easier to check that the code was working as expected. However, `bfs_dist()` requires that the value of `root` is numeric.\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nThe grid now repeats infinitely in all directions, and we need to take 26501365 steps.\n:::\n\nNot attempted (yet). My solution to Part 1 doesn't scale. \nMaybe I'll have to implement my own BFS after all!\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-22\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.4.526 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n adventdrob  * 0.0.1      2023-11-19 [1] Github (dgrtwo/adventdrob@491050f)\n aochelpers  * 0.1.0.9000 2023-12-06 [1] local\n dplyr       * 1.1.4      2023-11-17 [1] CRAN (R 4.3.1)\n forcats     * 1.0.0      2023-01-29 [1] CRAN (R 4.3.0)\n ggplot2     * 3.4.4      2023-10-12 [1] CRAN (R 4.3.1)\n lubridate   * 1.9.3      2023-09-27 [1] CRAN (R 4.3.1)\n purrr       * 1.0.2      2023-08-10 [1] CRAN (R 4.3.0)\n readr       * 2.1.4      2023-02-10 [1] CRAN (R 4.3.0)\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n tibble      * 3.2.1      2023-03-20 [1] CRAN (R 4.3.0)\n tidygraph   * 1.3.0      2023-12-18 [1] CRAN (R 4.3.1)\n tidyr       * 1.3.0      2023-01-24 [1] CRAN (R 4.3.0)\n tidyverse   * 2.0.0      2023-02-22 [1] CRAN (R 4.3.0)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n\n\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}