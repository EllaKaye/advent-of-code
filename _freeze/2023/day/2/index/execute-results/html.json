{
  "hash": "8c9dcaa566e586f0c92893f757918ded",
  "result": {
    "markdown": "---\ntitle: \"2023: Day 2\"\ndate: 2023-12-2\nauthor: \n  - name: Ella Kaye\ncategories: [base R, strings, regex]\ndraft: false\n---\n\n\n## Setup\n\n[The original challenge](https://adventofcode.com/2023/day/2)\n\n[My data](input){target=\"_blank\"}\n\n## Part 1\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(aochelpers)\ninput <- aoc_input_vector(2, 2023)\nhead(input)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Game 1: 4 blue, 7 red, 5 green; 3 blue, 4 red, 16 green; 3 red, 11 green\"                                                            \n[2] \"Game 2: 20 blue, 8 red, 1 green; 1 blue, 2 green, 8 red; 9 red, 4 green, 18 blue; 2 green, 7 red, 2 blue; 10 blue, 2 red, 5 green\"   \n[3] \"Game 3: 2 red, 5 green, 1 blue; 3 blue, 5 green; 8 blue, 13 green, 2 red; 9 green, 3 blue; 12 green, 13 blue; 3 green, 3 blue, 1 red\"\n[4] \"Game 4: 1 red, 6 green, 4 blue; 3 green, 1 blue, 1 red; 7 blue, 1 red, 2 green\"                                                      \n[5] \"Game 5: 2 green, 9 blue, 1 red; 3 green, 1 blue, 3 red; 1 red, 4 blue, 9 green\"                                                      \n[6] \"Game 6: 2 blue, 5 red, 7 green; 5 blue, 8 red, 3 green; 2 red, 9 blue, 2 green\"                                                      \n```\n:::\n:::\n\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nA game is possible if, in every draw, there are no more than 12 red cubes, 13 green cubes and 14 blue cubes. Find the sum of the IDs of the possible games.\n:::\n\nThis input looks like it might be well-suited to a tidyverse approach, but I decided to stick with base R plus **stringr**, solving the challenge via a series of custom functions.\n\nFirst, we need, in a couple of places, to extract the first number from a string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\nextract_first_num <- function(x) {\n\tx |> \n\t\tstr_extract(\"\\\\d+\") |> \n\t\tas.numeric()\n}\n```\n:::\n\n\nFrom a row of `input`, we next want a vector of the draws, \ni.e. not the game ID, and the string separated at the `\";\"`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_draws <- function(game) {\n\tgame |> \n\t\tstr_split(\":|;\") |> \n\t\tunlist() |> \n\t\ttail(-1) # discard the game ID\n}\n```\n:::\n\n\nFrom a draw, for each colour, we want to know the number of balls drawn:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolour_val <- function(draw, colour) {\n\t# separate colours\n\tsplit_draw <- str_split(draw, \",\") |> unlist() \n\n\t# get value for the color\n\tnum <- split_draw[str_detect(split_draw, colour)] |> \n\t\textract_first_num() |> \n\t\t\tas.numeric()\n\n\t# deal with 0-length vector if colour doesn't appear in draw\n\tifelse((length(num) == 1), num, 0) \n}\n```\n:::\n\n\nNow we can determine if a draw is possible:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndraw_possible <- function(draw) {\n\tif (colour_val(draw, \"red\") > 12 \n\t\t\t|| colour_val(draw, \"green\") > 13 \n\t\t\t|| colour_val(draw, \"blue\") > 14) {\n\t\tFALSE\n\t\t} else {\n\t\tTRUE\n\t}\n}\t\n```\n:::\n\n\nA game is possible if all draws are possible.\nFor a possible game, we want a function that returns the game ID.\nSince we'll be summing over these, we return 0 if the game is not possible.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngame_possible <- function(game) {\n\tgame_ID <- extract_first_num(game)\n\n\tdraws <- get_draws(game)\n\n\tall_possible <- draws |> \n\t\tsapply(draw_possible) |> \n\t\tall()\n\n\t\tifelse(all_possible, game_ID, 0)\n}\n```\n:::\n\n\nFinally, we check all games for whether they're possible, \nand find the sum of the IDs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n\tsapply(game_possible) |> \n\tsum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2512\n```\n:::\n:::\n\n\n\n## Part 2\n\n::: {.callout-note collapse=\"false\" icon=\"false\"}\n## The crux of the puzzle\nWhat is the fewest number of cubes of each colour that could have been in the bag to make the game possible? Multiply these together for each game (the *power*), then sum the power across all games.\n:::\n\nSome of the functions written for Part 1 come in handy here.\nWe need to look across all the draws in a game and find the max of each colour; that is the fewest of each colour we need. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nfewest_of_colour <- function(draws, colour) {\n\tdraws |> \n\t\tsapply(colour_val, colour) |> \n\t\tmax()\n}\n```\n:::\n\n\nTo find the power of a set of cubes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npower_cubes <- function(draws) {\n\tred <- fewest_of_colour(draws, \"red\")\n\tblue <- fewest_of_colour(draws, \"blue\")\n\tgreen <- fewest_of_colour(draws, \"green\")\n\n\tred * blue * green\n}\n```\n:::\n\n\nPutting these together, starting with the full `input`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput |> \n\tsapply(get_draws) |> \n\tsapply(power_cubes) |> \n\tsum()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 67335\n```\n:::\n:::\n\n\nI completed Day 2 without any recourse to LLMs.\n\n##### Session info {.appendix}\n\n<details><summary>Toggle</summary>\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n─ Session info ───────────────────────────────────────────────────────────────\n setting  value\n version  R version 4.3.2 (2023-10-31)\n os       macOS Sonoma 14.1\n system   aarch64, darwin20\n ui       X11\n language (EN)\n collate  en_US.UTF-8\n ctype    en_US.UTF-8\n tz       Europe/London\n date     2023-12-02\n pandoc   3.1.1 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)\n quarto   1.3.450 @ /usr/local/bin/quarto\n\n─ Packages ───────────────────────────────────────────────────────────────────\n package     * version    date (UTC) lib source\n aochelpers  * 0.1.0.9000 2023-12-02 [1] local\n sessioninfo * 1.2.2      2021-12-06 [1] CRAN (R 4.3.0)\n stringr     * 1.5.1      2023-11-14 [1] CRAN (R 4.3.1)\n\n [1] /Users/ellakaye/Library/R/arm64/4.3/library\n [2] /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library\n\n──────────────────────────────────────────────────────────────────────────────\n```\n:::\n:::\n\n\n</details>\n\n\n\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}